# 基于图像的分子表征学习在药物开发中的应用：方法、实现与应用的综合综述

## I. 引言

### A. AI驱动的药物发现中对先进分子表征的需求

人工智能（AI）的应用极大地推动了药物发现领域的发展。传统上，AI依赖于多种分子表征方式，如一维指纹图、二维描述符、用于自然语言处理（NLP）任务的简化分子线性输入系统（SMILES）字符串，以及用于图神经网络（GNN）的分子图。这些表征方法是基础性的，但在捕捉对药物开发流程中高精度预测至关重要的显式、细致的结构信息或复杂生物学特征方面可能存在局限性[^1]。例如，分子指纹图谱通常“未能反映分子的显式结构信息”，而NLP和GNN方法虽然功能强大，但在“准确捕捉分子特性和重要生物学特征方面的表达能力可能有限”[^1]。

每种化学物质固有的独特视觉表征为AI驱动的分析提供了一个直观且可能更强大的途径[^1]。向基于图像的方法论转变的驱动力来自几个优势：（1）通过分析图像中原子类型、其相对位置以及它们之间的连接，有效识别不同的化学物质；（2）能够利用计算机视觉（CV）领域中丰富、成熟且复杂的既有技术；（3）有潜力捕捉和提取通过其他表征形式难以获取的复杂潜在结构模式和属性关系[^1]。以往方法在全面编码分子信息方面的不足，直接推动了将视觉表征学习作为一种更具表现力的替代方案的探索和发展。

本报告全面综述了将分子数据转换为多种基于图像的模态的当代和新兴技术。具体而言，它将涵盖二维图像（静态和多通道）、三维表征（包括三维构象的二维快照、体素网格、基于表面的模型和点云）以及序列/视频格式。本报告将深入探讨图像生成的方法论，详细介绍基于Python的实现（重点是关键库和可用的代码示例），探索卷积神经网络（CNN）在药物发现中对这些表征的应用，并提供相关的学术引文。

### B. 报告的范围和方法结构

本报告旨在系统地探索分子到图像转换的领域，目标是为研究人员提供一份详细、技术性和可操作的指南。

探索将从**二维（2D）分子图像表征**开始，涵盖从SMILES字符串生成的标准2D描绘，以及将显式化学特征编码到图像层中的更高级多通道图像。

随后，报告将转向**三维（3D）分子表征**。此部分内容丰富，将详细讨论：

* 源自三维构象异构体的二维快照图像，捕捉多个视角。
* 适用于三维CNN的体素化网格表征。
* 关注分子拓扑结构和表面理化性质的基于表面的模型。
* 将分子表示为具有相关特征的三维坐标集的直接点云方法。

接着将探讨新兴的**分子序列和视频表征**领域，重点关注如VideoMol等旨在捕捉分子动力学的技术。

一个专门的部分将涵盖**多模态及其他相关方法**，包括图像数据与其他模态（文本、图）的整合、迁移学习策略和自监督学习范式。

对于每种不同的模态，讨论将强调：

* **生成技术**：将分子结构（主要来自SMILES、SDF或PDB格式）转换为目标图像类型的基本原理和算法。
* **关键工具和Python库**：实用性地关注广泛使用的工具，如RDKit、Maestro、PyMOL，以及专门的库如DeepChem和libmolgrid。
* **实现细节**：在可获得的情况下，将提供对公共代码库的引用（例如，来自[^1]的GitHub链接）和说明性的Python代码片段。
* **CNN应用**：具体示例说明这些图像表征如何与CNN和几何深度学习（GDL）模型结合，用于各种药物发现任务（例如，定量构效关系（QSAR）建模、吸收、分布、代谢、排泄和毒性（ADMET）预测、药物-靶点相互作用（DTI）识别）。

广义计算机视觉领域的快速发展和成功是基于图像的化学信息学的重要催化剂。CNN架构的成熟以及为通用视觉任务开发的预训练模型的可用性，大大降低了将这些技术应用于化学数据的“活化能”[^1]。这种技术的迁移是一个反复出现的主题。

报告最后将对这些模态进行比较总结，强调它们各自的优势、局限性和计算考量，随后展望未来的研究轨迹。基于图像的表征的探索是整合多样化数据类型的更大趋势的一部分。随着这些技术的成熟，它们与其他模态（如基因组数据、蛋白质组信息、文本描述[^1]和分子图）的融合，有望实现对药物行为和结构-性质关系更全面、更细致的理解。

## II. 二维（2D）分子图像表征

二维图像是分子最直接的视觉表征，通常源自SMILES字符串。它们具有简单和直观的特点，使其成为分子设计和分析，特别是高通量应用中一个引人注目的选择[^1]。

### A. 二维分子图像的生成

#### 1. 使用RDKit从SMILES生成

**RDKit**: 解析SMILES、生成二维坐标和渲染分子图像的主要库[^11]。其GitHub仓库是 `https://github.com/rdkit/rdkit`[^1]。

RDKit是一个核心的开源化学信息学工具包，广泛用于将SMILES字符串转换为二维分子图像[^1]。一般的工作流程包括解析SMILES字符串以创建RDKit Mol对象，生成用于描绘的二维坐标，然后将此布局渲染成图像格式，通常是Python中的PIL Image对象[^1]。

**关键RDKit模块和函数**：

* `Chem.MolFromSmiles()`：将SMILES字符串解析为RDKit Mol对象[^2]。
* `Draw.MolToImage()`：从Mol对象生成PIL Image。它允许基本的自定义，如图像大小、kekulization和楔形键的显示[^4]。
* `Draw.MolDraw2DCairo` 和 `Draw.MolDraw2DSVG`：高级2D绘图类。`MolDraw2DCairo`生成光栅图像（如PNG），`MolDraw2DSVG`生成矢量图像。它们提供更细致的绘图选项控制[^5]。
* `rdDepictor.Compute2DCoords()`：生成用于描绘的2D坐标。使用`rdDepictor.SetPreferCoordGen(True)`有助于实现更一致的分子朝向[^3]。`AllChem.Compute2DCoords()`是另一种选择[^11]。

**针对CNN输入的关键参数和自定义**：

* **图像大小**：一致性对CNN输入至关重要。
    * DEEPScreen使用200x200像素[^12]。
    * ImageMol默认为224x224像素[^13]。
    * Chemception通常使用80x80像素[^14]。
    * RDKit的`MolToImage`接受一个`size`元组。`MolDraw2DCairo`则在初始化时指定宽度和高度。
* **分辨率和细节**:
    * `DrawingOptions.dotsPerAngstrom`（用于`MolToImage`）控制像素密度相对于分子大小的比例[^16]。
    * `MolDrawOptions.fixedBondLength`可以固定键在图像中的像素长度，以实现一致的缩放[^10]。
* **原子和键的高亮**:
    * `highlightAtoms`和`highlightBonds`参数可用于`MolToImage`以及绘图类的`DrawMolecule`方法[^4]。
    * `highlightColor`（用于`MolToImage`）或`MolDrawOptions.highlightColour`设置高亮颜色[^4]。
    * `MolDrawOptions.atomColourPalette`或`MolDraw2D.DrawMolecule(highlightAtomColors={atom_index: (R,G,B)})`允许自定义特定原子的颜色[^7]。
* **原子和键的颜色**:
    * `MolDrawOptions.setAtomPalette({atom_index: (R,G,B)})`可以设置自定义的原子颜色调色板[^10]。RDKit Cookbook也展示了使用`useBWAtomPalette()`生成黑白图像的方法[^6]。
* **图例 (Legends)**:
    * `DrawMolecule`中的`legend`参数或`MolsToGridImage`中的`legends`参数可以添加文本注释[^4]。
    * `MolDrawOptions`如`legendFontSize`和`legendFraction`控制图例外观[^10]。

**Python代码片段 (基础 `MolToImage`)**:
```python
from rdkit import Chem
from rdkit.Chem.Draw import MolToImage

mol = Chem.MolFromSmiles("CN1C=NC2=C1C(=O)N(C(=O)N2C)C") # Caffeine
img = MolToImage(mol, size=(256, 256))
# img.save("caffeine_2d.png")
```

*(概念性, 基于[^4])*

**Python代码片段 (`MolDraw2DCairo` 带高亮)**:

Python

```python
from rdkit import Chem
from rdkit.Chem.Draw import rdMolDraw2D
from io import BytesIO # 用于在内存中处理图像数据
# from PIL import Image # 用于查看或保存图像

mol = Chem.MolFromSmiles("Cc1ccccc1O") # o-cresol
# 高亮甲基所在的子结构 (假设原子0是甲基碳，原子1是与之相连的芳香碳)
# 精确的索引取决于SMILES的规范化和原子顺序
# 为了更稳健地高亮，可以使用子结构匹配获取索引
substructure = Chem.MolFromSmarts("c(C)O") # 带有甲基和羟基的芳香碳
match = mol.GetSubstructMatch(substructure)

drawer = rdMolDraw2D.MolDraw2DCairo(300, 300) # width, height
# drawer.drawOptions().addAtomIndices = True # 可选：添加原子索引
# drawer.drawOptions().setHighlightColour((0.0, 0.0, 1.0, 0.5)) # 蓝色, 0.5透明度

# 自定义原子颜色示例
atom_colors = {}
if match:
    for atom_idx in match:
        if mol.GetAtomWithIdx(atom_idx).GetSymbol() == 'O':
            atom_colors[atom_idx] = (1.0, 0.0, 0.0) # 子结构中的氧原子用红色
        elif mol.GetAtomWithIdx(atom_idx).GetSymbol() == 'C':
             atom_colors[atom_idx] = (0.0, 0.0, 1.0) # 子结构中的碳原子用蓝色

drawer.DrawMolecule(mol, highlightAtoms=match, highlightAtomColors=atom_colors, legend="o-cresol with substructure highlight")
drawer.FinishDrawing()
png_data = drawer.GetDrawingText() # 获取PNG数据 (bytes)
# with open("o_cresol_highlighted.png", "wb") as f:
#     f.write(png_data)
# pil_image = Image.open(BytesIO(png_data))
# pil_image.show()
```

*(概念性, 基于[^6])*





#### ImageMol实现

官方PyTorch实现托管在GitHub上的`HongxinXiang/ImageMol`[^13]。用于图像生成的关键脚本包括`smiles2img_pretrain.py`和`dataloader/image_dataloader.py`[^13]。

```python
def smiles_to_image(smis, size=224, save_path=None):
    try:
        mol = Chem.MolFromSmiles(smis)
        img = Draw.MolsToGridImage([mol], molsPerRow=1, subImgSize=(size, size))
        if save_path is not None:
            img.save(save_path)
        return img
    except:
        return None
```

以下是实现这一功能的代码：

```python
import os
import torch
import torchvision.models as models
import torchvision.transforms as transforms
from rdkit import Chem
from rdkit.Chem import Draw
import requests
from tqdm import tqdm
from PIL import Image
import tempfile

def smiles_or_mol_to_latent(smiles_or_mol, model_name="ResNet18", image_size=224, 
                           pretrained_url="https://drive.usercontent.google.com/download?id=1wQfby8JIhgo3DxPvFeHXPc14wS-b4KB5&export=download&authuser=0",
                           cache_dir=None, force_download=False):
    """
    将 SMILES 字符串或 RDKit Mol 对象转换为 latent feature
    
    参数:
        smiles_or_mol: SMILES 字符串或 RDKit Mol 对象
        model_name: 模型架构名称，默认为 "ResNet18"
        image_size: 图像大小，默认为 224x224
        pretrained_url: 预训练模型的下载链接
        cache_dir: 缓存目录，用于存储下载的模型
        force_download: 是否强制重新下载模型
    
    返回:
        latent_feature: 提取的 latent feature，形状为 (batch_size, feature_dim)
    """
    # 确保缓存目录存在
    if cache_dir is None:
        cache_dir = os.path.join(tempfile.gettempdir(), "imagemol_cache")
    os.makedirs(cache_dir, exist_ok=True)
    
    # 定义模型文件路径
    model_path = os.path.join(cache_dir, "ImageMol.pth.tar")
    
    # 处理输入为 SMILES 字符串的情况
    if isinstance(smiles_or_mol, str):
        mol = Chem.MolFromSmiles(smiles_or_mol)
        if mol is None:
            raise ValueError(f"无法解析 SMILES 字符串: {smiles_or_mol}")
    else:
        mol = smiles_or_mol
    
    # 生成分子图像
    img = Draw.MolsToGridImage([mol], molsPerRow=1, subImgSize=(image_size, image_size))
    img_path = os.path.join(cache_dir, "temp_molecule.png")
    img.save(img_path)
    
    # 下载预训练模型（如果需要）
    if force_download or not os.path.exists(model_path):
        print("开始下载预训练模型...")
        download_file_from_google_drive(pretrained_url, model_path)
        print(f"模型已下载到: {model_path}")
    
    # 加载模型
    model = load_pretrained_model(model_name, image_size=image_size)
    
    # 加载预训练权重
    try:
        checkpoint = torch.load(model_path, map_location=torch.device('cpu'))
        model.load_state_dict(checkpoint['model_state_dict'])
        print("=> 成功加载预训练权重")
    except Exception as e:
        print(f"=> 加载预训练权重失败: {e}")
        print("尝试直接从 torchvision 加载预训练权重...")
        model = load_pretrained_model(model_name, image_size=image_size, pretrained=True)
    
    # 设置为评估模式
    model.eval()
    
    # 图像预处理
    transform = transforms.Compose([
        transforms.Resize((image_size, image_size)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])
    
    # 加载并预处理图像
    img = Image.open(img_path).convert('RGB')
    img_tensor = transform(img).unsqueeze(0)
    
    # 获取 latent feature
    with torch.no_grad():
        # 移除最后一层全连接层以获取 latent feature
        embedding_layer = list(model.children())[:-1]
        embedding_model = torch.nn.Sequential(*embedding_layer)
        latent_feature = embedding_model(img_tensor)
        # 调整形状为 (batch_size, feature_dim)
        latent_feature = latent_feature.squeeze(-1).squeeze(-1)
    
    return latent_feature

def load_pretrained_model(model_name="ResNet18", image_size=224, pretrained=False):
    """加载预训练模型"""
    if model_name == "ResNet18":
        model = models.resnet18(pretrained=pretrained)
        # 修改最后一层以适应任何输出类别数
        model.fc = torch.nn.Linear(model.fc.in_features, 2)
    elif model_name == "ResNet34":
        model = models.resnet34(pretrained=pretrained)
        model.fc = torch.nn.Linear(model.fc.in_features, 2)
    elif model_name == "ResNet50":
        model = models.resnet50(pretrained=pretrained)
        model.fc = torch.nn.Linear(model.fc.in_features, 2)
    else:
        raise ValueError(f"不支持的模型架构: {model_name}")
    
    return model

def download_file_from_google_drive(url, destination):
    """从 Google Drive 下载文件"""
    # 提取文件 ID
    file_id = url.split('/')[-2] if 'view' in url else url.split('/')[-1]
    base_url = 'https://docs.google.com/uc?export=download'
    
    session = requests.Session()
    response = session.get(base_url, params={'id': file_id}, stream=True)
    
    # 检查是否需要确认下载
    for key, value in response.cookies.items():
        if key.startswith('download_warning'):
            params = {'id': file_id, 'confirm': value}
            response = session.get(base_url, params=params, stream=True)
            break
    
    # 下载文件
    CHUNK_SIZE = 32768
    with open(destination, 'wb') as f:
        with tqdm(unit='B', unit_scale=True, unit_divisor=1024) as bar:
            for chunk in response.iter_content(CHUNK_SIZE):
                if chunk:  # filter out keep-alive new chunks
                    f.write(chunk)
                    bar.update(len(chunk))
```

这个函数的主要功能和特点：

1. **自动处理输入**：可以接受 SMILES 字符串或 RDKit Mol 对象作为输入
2. **自动模型下载**：首次调用时会自动从 Google Drive 下载预训练模型，并缓存到本地
3. **特征提取**：使用预训练模型将分子图像转换为固定维度的 latent feature
4. **缓存机制**：避免重复下载模型，提高后续调用效率
5. **错误处理**：包含输入验证和错误处理，确保函数健壮性

使用示例：

```python
# 从 SMILES 获取 latent feature
smiles = "CCO"  # 乙醇的 SMILES
feature = smiles_or_mol_to_latent(smiles)
print(f"特征形状: {feature.shape}")

# 从 RDKit Mol 对象获取 latent feature
from rdkit import Chem
mol = Chem.MolFromSmiles("CCO")
feature = smiles_or_mol_to_latent(mol)
print(f"特征形状: {feature.shape}")
```

这个函数默认使用 ResNet18 架构，输出的 latent feature 维度为 512。如果需要其他架构，可以通过 `model_name` 参数指定。



#### 2. Chemception多通道二维图像

Chemception实现

https://sharifsuliman.medium.com/designing-a-convolutional-neural-network-for-cannabis-machine-learning-part-1-e5a2d8f667af

- Goh等人的原始工作（2017）[^15]奠定了基础。
- 一个公开的实现是GitHub上的`Abdulk084/Chemception`[^1]，它使用Keras和TensorFlow。核心逻辑通常在Jupyter笔记本（如`chemcemption.ipynb`）中找到[^20]。

二维分子成像在CNN应用中的一个重要进展是将显式的化学特征直接编码到图像通道中（例如RGB或RGBA），而不仅仅依赖于视觉结构。这为神经网络提供了更丰富、信息量更大的输入。

Chemception方法:

最初的Chemception论文描述了使用灰度图像，其中原子表示为按原子序数着色的点，键表示为线[^14]。

后续工作，特别是Goh等人的研究（2017年）以及Wildcard Consulting的一篇博客文章详细介绍了一种4通道图像的方法[^18]。这种多通道表示允许CNN“看到”特定位置的化学性质。

chemcepterize_mol（详见[^11] https://github.com/Abdulk084/Chemception/blob/master/chemcemption.ipynb）例证了这一点：

- **通道0**: 编码键级 (例如，单键为1.0，双键为2.0)。
- **通道1**: 编码原子序数。
- **通道2**: 编码原子杂化状态 (例如，sp, sp2, sp3 表示为数值)。
- **通道3**: 编码Gasteiger部分电荷。

图像尺寸通常不大，例如80x80像素[^14]或博客文章示例中的48x48像素[^11]。



```python
def chemcepterize_mol(mol, embed=20.0, res=0.5):
    dims = int(embed*2/res)
    #print(dims)
   
    #print(mol)
    #print(",,,,,,,,,,,,,,,,,,,,,,")
    cmol = Chem.Mol(mol.ToBinary())
    #print(cmol)
    #print(",,,,,,,,,,,,,,,,,,,,,,")
    cmol.ComputeGasteigerCharges()
    AllChem.Compute2DCoords(cmol)
    coords = cmol.GetConformer(0).GetPositions()
    #print(coords)
    #print(",,,,,,,,,,,,,,,,,,,,,,")
    vect = np.zeros((dims,dims,4))
    #Bonds first
    for i,bond in enumerate(mol.GetBonds()):
        bondorder = bond.GetBondTypeAsDouble()
        bidx = bond.GetBeginAtomIdx()
        eidx = bond.GetEndAtomIdx()
        bcoords = coords[bidx]
        ecoords = coords[eidx]
        frac = np.linspace(0,1,int(1/res*2)) #
        for f in frac:
            c = (f*bcoords + (1-f)*ecoords)
            idx = int(round((c[0] + embed)/res))
            idy = int(round((c[1]+ embed)/res))
            #Save in the vector first channel
            vect[ idx , idy ,0] = bondorder
    #Atom Layers
    for i,atom in enumerate(cmol.GetAtoms()):
            idx = int(round((coords[i][0] + embed)/res))
            idy = int(round((coords[i][1]+ embed)/res))
            #Atomic number
            vect[ idx , idy, 1] = atom.GetAtomicNum()
            #Gasteiger Charges
            charge = atom.GetProp("_GasteigerCharge")
            vect[ idx , idy, 3] = charge
            #Hybridization
            hyptype = atom.GetHybridization().real
            vect[ idx , idy, 2] = hyptype
            
    return vect
```

5. **输出与可视化**

```python
v = chemcepterize_mol(mol, embed=10, res=0.2)
print(v.shape)  # 输出：(100, 100, 4)（假设embed=10，res=0.2时dims=100）
plt.imshow(v[:,:,:3])  # 可视化前3个通道（模拟RGB图像）
```

- 输出的`vect`是一个**3 维数组**，形状为`(dims, dims, 4)`，可直接作为 CNN 的输入（类似图像的`(H, W, C)`格式）。
- `imshow(v[:,:,:3])`将前 3 个通道视为 RGB 通道进行可视化，实际每个通道代表不同的化学属性，而非颜色。



#### KekuleScope

https://github.com/isidroc/kekulescope

代码可在GitHub上的`isidroc/kekulescope`找到[^1]。它包括Python脚本如`Kekulescope.py`和`load_images.py`，并利用PyTorch框架[^22]。

分子转图片的代码主要来自于 `kekulescope/Kekulescope.py` 文件。下面是将分子转换为图片的核心代码片段，我们将其提取并进行适当修改，使其成为一个独立可用的代码片段：

```python
import os
import sys
from rdkit import Chem
from rdkit.Chem import Draw
import glob

# 定义函数来生成分子图片
def generate_molecule_images(cell_line, seed, smiles_list, chembl_ids, dataset_type):
    base_dir = f'./images/{cell_line}/{seed}/{dataset_type}/images'
    os.makedirs(base_dir, exist_ok=True)

    svgs = glob.glob(f"{base_dir}/*svg")
    pngs = glob.glob(f"{base_dir}/*png")
    if len(svgs) == 0 and len(pngs) == 0:
        for i, smiles in enumerate(smiles_list):
            mol = Chem.MolFromSmiles(smiles)
            if mol is not None:
                svg_img = Draw.MolsToGridImage([mol], molsPerRow=1, useSVG=True)
                with open(f'{base_dir}/{chembl_ids[i]}.svg', 'w') as f:
                    f.write(svg_img.data)
    else:
        print(f"SVGs ready for {dataset_type}")

    # 将 SVG 转换为 PNG
    pngs = glob.glob(f"{base_dir}/*png")
    if len(pngs) == 0:
        basedir = os.getcwd()
        os.chdir(base_dir)
        cmd = "AA=($( find . -name '*.svg'  ));for i in ${AA[*]}; do convert -density 800 ${i} -resize 300x ${i}.png ; done"
        os.system(cmd)
        cmd = "rm -rf *.svg"
        os.system(cmd)
        os.chdir(basedir)


# 示例使用
if __name__ == "__main__":
    cell_line = "KB"
    seed = 1
    # 这里需要替换为实际的 SMILES 列表和 ChEMBL ID 列表
    my_smiles = ["CCO", "CCOC"]
    chembl_ids = ["CHEMBL1", "CHEMBL2"]

    # 生成训练集图片
    generate_molecule_images(cell_line, seed, my_smiles, chembl_ids, "train")
    # 生成验证集图片
    generate_molecule_images(cell_line, seed, my_smiles, chembl_ids, "val")
    # 生成测试集图片
    generate_molecule_images(cell_line, seed, my_smiles, chembl_ids, "test")
```

代码说明

**函数 `generate_molecule_images`**：该函数接受细胞系名称、随机种子、SMILES 列表、ChEMBL ID 列表和数据集类型（train、val 或 test）作为输入。它首先检查目标目录下是否已经存在 SVG 或 PNG 文件，如果不存在，则生成 SVG 图片；然后将 SVG 图片转换为 PNG 图片，并删除 SVG 文件。

**KekuleScope**: 采用“凯库勒结构表示”作为CNN的输入[^1]。相关的GitHub仓库`isidroc/kekulescope`包含一个`load_images.py`脚本，推测用于处理图像生成或加载，并利用了RDKit[^1]。

#### DEEPScreen

https://github.com/cansyl/DEEPScreen

主要通过 `rdkit` 库将 SMILES 字符串转换为分子对象，然后使用 `rdkit` 的绘图功能将分子绘制为 SVG 图像，再使用 `cairosvg` 将 SVG 图像转换为 PNG 图像，最后删除临时的 SVG 文件。

```python
import os
import subprocess
from rdkit import Chem
from rdkit.Chem import Draw
from rdkit.Chem.Draw import DrawingOptions
import cairosvg

# 假设训练文件路径
training_files_path = "/path/to/training_files"
IMG_SIZE = 200

def save_comp_imgs_from_smiles(tar_id, comp_id, smiles):
    """
    将分子的 SMILES 表示转换为图片
    :param tar_id: 目标 ID
    :param comp_id: 化合物 ID
    :param smiles: 分子的 SMILES 字符串
    """
    # 创建分子对象
    mol = Chem.MolFromSmiles(smiles)
    # 设置绘图选项
    DrawingOptions.atomLabelFontSize = 55
    DrawingOptions.dotsPerAngstrom = 100
    DrawingOptions.bondLineWidth = 1.5
    # 绘制分子为 SVG 图像
    svg_path = os.path.join(training_files_path, "target_training_datasets", tar_id, "imgs", "{}.svg".format(comp_id))
    Draw.MolToFile(mol, svg_path, size=(IMG_SIZE, IMG_SIZE))
    # 将 SVG 图像转换为 PNG 图像
    png_path = os.path.join(training_files_path, "target_training_datasets", tar_id, "imgs", "{}.png".format(comp_id))
    cairosvg.svg2png(url=svg_path, write_to=png_path)
    # 删除临时的 SVG 文件
    subprocess.call(["rm", svg_path])


# 示例使用
tar_id = "example_target"
comp_id = "example_compound"
smiles = "CCO"  # 示例 SMILES 字符串

# 创建必要的目录
target_dir = os.path.join(training_files_path, "target_training_datasets", tar_id, "imgs")
os.makedirs(target_dir, exist_ok=True)

# 调用函数生成图片
save_comp_imgs_from_smiles(tar_id, comp_id, smiles)
```

代码说明

1. **文件来源**：此代码片段来自 `bin/data_processing.py` 文件。
2. **依赖安装**：需要安装 `rdkit` 和 `cairosvg` 库，可以使用以下命令进行安装

**DEEPScreen**: 使用通过RDKit从SMILES生成的二维结构表示（200x200像素）。值得注意的是，由于SMILES表示的局限性，手性信息被省略了，而非图像生成过程本身的问题[^12]。





#### 3. 其他工具中的特定二维图像生成

其他一些工具和研究也利用二维图像，通常以RDKit作为生成引擎，没见代码：

- **Toxic Colors**: 使用2DConvNet处理“化学品的简单二维绘图”或“简易二维草图”[^1]。具体的生成细节可能在其补充材料中[^23]。https://pubs.acs.org/doi/full/10.1021/acs.jcim.8b00338  用的是MOE
- **ADMET-CNN**: 一种基于分子二维图像的CNN，用于预测ADMET性质[^1]。https://www.sciencedirect.com/science/article/pii/S0169743919303417?via%3Dihub#sec5  RDKit
- **QSAR-CNN (Zhong et al., 2021)**: 利用分子图像进行QSAR建模，特别是用于预测污染物的反应性[^1]。https://www.sciencedirect.com/science/article/pii/S1385894720341176  RDKit
- InterpretableDTIP ([Gao et al., 2018](https://www.frontiersin.org/journals/molecular-biosciences/articles/10.3389/fmolb.2022.963912/full#B13)) and CPI-GNN ([Tsubaki et al., 2019](https://www.frontiersin.org/journals/molecular-biosciences/articles/10.3389/fmolb.2022.963912/full#B52); [Chen et al., 2020](https://www.frontiersin.org/journals/molecular-biosciences/articles/10.3389/fmolb.2022.963912/full#B5)) first convert the SMILES sequences into molecular graph with the Rdkit

从简单的二维草图到标准化的RDKit描绘，再到富含化学特征的多通道图像的演变，反映了为CNN提供更直接可用和信息更丰富的输入的持续努力。这旨在减轻网络学习基本化学特征的负担，从而可能带来性能或数据效率的提升。

### B. 基于二维图像的CNN架构与应用

标准的CNN架构，包括AlexNet、VGG、ResNet、DenseNet和基于Inception的模型，经常被调整或用作处理二维分子图像的基础骨干网络[^1]。这些网络通常包含用于层次化特征提取的卷积层、用于降维和实现平移不变性的池化层，以及用于将学习到的特征映射到输出预测的全连接层[^1]。

**应用领域**:

- **生物活性和性质预测**: 这是一个主要的应用领域。KekuleScope预测癌细胞系的敏感性和化合物效价[^21]。Chemception已应用于预测毒性、生化活性和溶解性质[^14]。ImageMol专注于预测一系列分子性质和药物靶点[^13]。ADMET-CNN专为ADMET性质预测而设计[^25]，QSAR-CNN模型用于预测污染物反应性等任务[^33]。
- **毒性预测**: Toxic Colors利用二维图像进行Tox21基准测试预测[^23]。Deepsnap虽然常与三维输入相关联，但在毒性预测的背景下也被引用，其中可能使用二维图像[^1]。ResNet18DNN被引用用于预测药物引起的肝损伤（DILI）[^1]。BESTox从其SMILES衍生的二元矩阵预测急性口服毒性[^37]。
- **药物-靶点相互作用 (DTI)**: DEEPScreen是一个显著的例子，使用二维结构图像预测DTI[^12]。

**具体模型示例**:

- **KekuleScope**: 扩展了成熟的架构，如AlexNet、DenseNet-201、ResNet152和VGG-19，通常利用在通用图像数据集（如ImageNet）上预训练的权重作为一种迁移学习形式[^1]。
- **Chemception**: 受Google的Inception-ResNet架构启发，证明了当使用基于图像的输入时，最少的显式化学知识也能产生有竞争力的结果[^14]。
- **ImageMol**: 采用自监督图像表征学习框架。其预训练脚本提到了ResNet18，表明可能使用ResNet骨干网络从大量未标记的分子图像中学习[^13]。
- **ResNet18DNN**: 特别使用一个18层的残差神经网络（ResNet18）结合深度神经网络进行DILI预测[^1]。综述[^1]将其归类为基于图像的方法，尽管一些使用CNN进行DILI预测的具体研究也采用了指纹输入[^40]。

使用标准化的图像尺寸和朝向，如DEEPScreen[^12]所示，对CNN至关重要，因为CNN对输入变化敏感。如果同一个分子可以有多种描绘方式，网络可能会学到虚假的关联。像Chemception这样的多通道方法试图以结构化的方式增加特征丰富度，这在一定程度上独立于确切的二维布局。此外，将CNN应用于SMILES字符串的二维矩阵表示（例如，Hirohara M. et al.[^36], BESTox[^37]）表明，“基于图像”有时可以指CNN在二维张量输入上的维度和局部模式学习能力，而不仅仅是其视觉来源。

RDKit和Python的广泛可用性，加上成熟的深度学习框架，使得基于二维图像的方法相对容易获取。然而，优化描绘参数和设计有效的多通道表示（如Chemception所示）仍然需要相当的领域专业知识，以确保呈现给CNN的视觉特征是有意义的，并且有助于学习相关的结构-性质关系。

还有并非分子图像的

- **Hirohara M. et al.**: 这种方法略有不同，它将SMILES字符串转换为“SMILES特征矩阵”（例如，一个400x42的矩阵）。虽然不是视觉图像，但这个二维矩阵由CNN处理，展示了CNN在结构化二维序列表示上的应用[^36]。
- **BESTox**: 类似地，此方法使用从SMILES派生的“二维二元矩阵”，编码了原子类型、键合氢数量、电荷、化合价等特征。这个矩阵（而非视觉描绘）作为CNN输入[^1]。
- **tCNNs (Liu et al.)**: 该模型通过将SMILES字符串转换为one-hot编码矩阵来处理它们。然后将一维CNN应用于药物的矩阵表示[^41]。虽然输入是从序列派生的矩阵，但其二维结构和CNN的处理方式使其处于一种模糊了纯序列和类图像表示界限的类别，正如其被包含在基于图像的综述中一样[^1]。



## III. 三维（3D）分子表征

虽然二维图像提供了简单性，但它们固有地丢失了显式的三维结构信息，而这些信息对于理解分子相互作用（尤其是在药物-靶点结合中）通常至关重要。为了解决这个问题，已经开发了各种三维表征策略，范围从三维构象的二维快照集合到用于专门CNN和几何深度学习（GDL）模型的直接体素化或基于表面的输入。

### A. 三维分子表征的生成

#### 1. 源自构象异构体的三维快照图像

这种方法试图通过从不同视角捕捉分子三维构象的多个二维投影图像，从而为主要是二维的CNN提供三维信息。

- Maestro (Schrödinger)

  - **方法**: 这个商业软件包可用于导入三维构象（例如，从SDF文件）。一种常用技术是在固定角度增量（例如，8次旋转，每次45°）下围绕特定轴（例如y轴）全局旋转构象。每次旋转后，保存三维模型的当前二维视图为图像。重要的是，这些用于可视化的全局旋转不改变分子的潜在三维坐标[^1]。
  - **应用示例**: Asilar等人（2020）在其“基于图像的CNN”工作中应用此技术预测肝毒性。从Maestro生成的图像通常用不同颜色描绘原子，用管状表示键，传达基本的化学和结构信息[^1]。
  - **代码**: Maestro允许使用Python脚本自动化此类工作流程。GitHub仓库`https://github.com/maestro-project/maestro`[^1]似乎是一个独立的项目，并非官方的Schrödinger Maestro软件。
  
- Deepsnap (Uesawa Y., Matsuzaka Y.)

  - **方法**: 这种新颖的分子图像输入技术是为QSAR分析而开发的。它从三维化学结构生成图像，提供用户可调参数，如原子属性（可能影响描绘）、原子颜色、键半径和像素大小。一个关键方面是从多个视角捕捉图像，这有助于揭示关键的致毒构象或药理学相关的结构域[^1]。
  - Uesawa Y.（2018）特别描述了“Deep Snap”过程：使用CORINA Classic软件从SMILES生成三维结构并保存为SDF，然后使用Jmol将其可视化为球棍模型。这些模型随后围绕X、Y和Z轴系统地旋转360°，并以定义的增量捕捉快照（例如，每个轴向8张图像，45°增量，每个分子产生512张图像）。这些图像通常保存为256x256像素的PNG文件[^54]。由此产生的图像集用于训练AlexNet CNN模型。
  - **代码**: 综述中引用的GitHub链接`snap-stanford/deepsnap`[^1]涉及一个用于图深度学习的Python库，似乎与Uesawa和Matsuzaka开发的Deepsnap QSAR图像方法不同[^55]。图像方法的相关引文是Matsuzaka Y, Uesawa Y. "Optimization of a deep-learning method based on the classification of images generated by parameterized deep snap..."[^1]。
  - 我怎么看还有MOE
  
- RDKit用于从3D生成多视角2D投影

  - RDKit的`MolDraw3D`模块主要用于创建交互式3D可视化或静态3D透视图像，而不是一系列适用于CNN序列输入的、从系统变化的视点生成的2D投影[^56]。虽然理论上可以编写RDKit脚本来旋转三维构象的坐标，然后为每个旋转状态生成标准的2D描绘，但这并非内置的高级功能，需要自定义实现。像PyMOL这样的工具更常用于生成此类多帧旋转序列（如VideoMol所示）。

#### 2. 基于三维体素的表征 (网格)

体素化涉及将分子或蛋白质-配体复合物占据的三维空间离散化为一个规则的体积元素（体素）网格。每个体素随后可以存储代表原子存在、原子类型或其他理化性质的标量或矢量值，通常形成多个通道。这种三维“图像”直接适用于三维CNN。

**一般过程**：该过程通常包括定义一个边界框，设置网格分辨率（体素大小），将分子放置在此网格内，然后根据落入或靠近每个体素的原子为其分配特征值。

**工具和方法**:

- AtomNet (Wallach et al., 2015) 和 Ragoza et al. (2017)

  - AtomNet是基于结构的生物活性预测的开创性深度CNN，利用蛋白质-配体复合物的三维网格表示[^60]。输入生成涉及将配体置于网格盒中心，并将原子类型和位置特征化为体素通道[^62]。
  - Ragoza等人（用户查询中提到“voxelization, smina atom types”）及相关工作如CENsible研究[^63]描述了使用libmolgrid对蛋白质-配体复合物进行体素化。例如，使用的参数包括0.5 Å的分辨率，48x48x48的网格，以及28种原子类型（可能是类smina或类AutoDock的原子类型）。
  
- DeepSite (Jimenez et al.)

  - 一种基于三维CNN的方法，用于预测蛋白质上的配体结合位点[^65]。
  - 它将蛋白质结构表示为离散化为1x1x1 Å³体素的三维图像。网格包含蛋白质的边界框外加8 Å的缓冲层以捕捉表面口袋[^66]。
  - 一个关键特征是其使用8个通道表示体素占据情况，编码不同的原子特性：疏水性、芳香性、氢键受体、氢键供体、正离子化、负离子化、金属性以及一个通用的排除体积通道。这些特性源自AutoDock 4的原子类型[^66]。
  - DeepSite网络服务器位于 `www.playmolecule.org`[^70]。
  
- KDEEP 和 Ligdream

  :

  - 这些工具在用户查询中被提及并在综述中列出[^1]，据称重用或类似于DeepSite的体素化方法。例如，KDEEP也采用三维网格表示[^61]。

- Pafnucy (Stepniewska-Dziubinska et al.)

  :

  - 使用三维CNN预测蛋白质-配体结合亲和力[^61]。
  - 输入是一个以配体几何中心为中心的20 Å立方体盒子，离散化为1 Å分辨率的网格。这形成一个4D张量，最后一个维度包含每个网格点的19个原子特征[^72]：9位用于原子类型（B, C, N, O, P, S, Se, 卤素, 金属）；1个整数表示杂化状态；1个整数表示重原子价；1个整数表示杂原子价；5位用于SMARTS定义的属性（疏水性、芳香性、受体、供体、环）；1个浮点数表示部分电荷；1个整数区分配体（1）和蛋白质（-1）。如果多个原子占据单个体素，则其特征相加[^76]。
  - 代码和使用说明可在 `http://gitlab.com/cheminfIBB/pafnucy` 获取[^76]。

- Kuzminykh D. et al. (2018)

  :

  - 这项工作直接解决了朴素体素表示中极端稀疏性的问题。他们提出了一种基于小波变换的新颖平滑方法，通过将初始离散表示与小波核进行卷积，原子被有效地“扩展”以填充附近的体素[^1]。
  - 这种小波变换方法与高斯平滑（模糊）进行了比较。作者认为，与高斯核的简单指数衰减相比，小波变换导致的信息损失更少，并且来自不同原子的波之间的干涉能够更好地传播信息[^78]。
  - 输入生成包括获取三维构象（例如，通过PCA定向从SMILES生成），将空间离散化为网格（例如，0.5 Å分辨率），并用原子类型（例如，对常见元素H, C, N, O, F, S使用6-9个通道的one-hot编码）表示每个单元格中的原子[^78]。

**体素化的Python库**:

- **libmolgrid**: 一个通用的C++/CUDA库，带有Python绑定，专为机器学习创建体素化分子数据而设计。它支持各种原子类型方案（例如，XS原子类型、元素类型、自定义回调），可以处理多个坐标集（例如，受体和配体），并包含用于高效批量采样ExampleProvider和用于生成网格张量的GridMaker。它针对GPU加速进行了优化[^63]。代码位于GitHub上的`gnina/libmolgrid`。

- DeepChem

  :

  - `RdkitGridFeaturizer`: 位于`deepchem/feat/complex_featurizers/rdkit_grid_featurizer.py`，此特征化器专为蛋白质-配体复合物设计。它创建一个以配体为中心的网格，并可以将各种特征类型编码到体素通道中，例如ECFP、SPLIF、Sybyl原子类型、电荷、氢键势、π-堆积和阳离子-π相互作用。参数包括`box_width`、`voxel_width`、`feature_types`和用于通过旋转复合物进行数据增强的`nb_rotations`[^85]。
  - 虽然用户查询中提到了通用的`VoxelFeaturizer`，但在提供的材料中，`RdkitGridFeaturizer`更具体地记录了用于创建三维网格。DeepChem提供了一套广泛的特征化器[^87]。
  - 代码: GitHub上的`deepchem/deepchem`[^86]。

- **MolVoxel**: (`SeonghwanSeo/molvoxel`) 一个易于使用的Python分子体素化工具，依赖项极少（NumPy、SciPy，可选Numba、PyTorch/CUDA、RDKit、PyMOL）。它以原子坐标、半径和特征作为输入。参数包括分辨率（默认0.5）、维度（默认64）、密度类型（‘gaussian’或‘binary’）和sigma（用于高斯核，默认0.5）[^89]。

- **NEARL**: (`miemiemmmm/Nearl`) 一个自动化的Python流程，旨在从分子动力学（MD）轨迹的大量系综中提取动态特征，重点是用于三维CNN的三维体素表示。一个示例将特定残基附近的子结构的质量分布特征化为一个32x32x32的网格[^90]。

体素网格中的稀疏性问题是一个重要的考虑因素。如果原子在大型三维网格中表示为单个点，则大多数体素将保持为空，导致计算效率低下，并可能妨碍三维CNN的学习过程。像Kuzminykh的小波变换、高斯模糊或将网格聚焦于感兴趣区域（例如，配体或结合位点周围）等技术对于创建更密集、信息更丰富的表示至关重要。

#### 3. 基于三维表面的表征

这些方法通过分子的三维表面（特别是蛋白质）来表示分子，并将理化或几何特征编码到这些表面上。然后，几何深度学习模型可以在这些表面网格或从它们派生的面片上操作。

- MaSIF (Molecular Surface Interaction Fingerprints) (Gainza et al.)

  :

  - 方法

    : MaSIF是一种著名的方法，它处理蛋白质表面以解读对生物分子相互作用重要的模式[^1]。

    - **表面生成**: 它计算分子表面（使用MSMS计算溶剂排除表面）并将其离散化为网格。
    - **特征分配**: 将几何特征（例如，形状指数、距离依赖曲率）和化学特征（例如，氢键供体/受体势、通过APBS计算的静电势，以及通过PDB2PQR原子参数计算的疏水性）分配给网格的每个顶点。
    - **面片提取**: 在每个顶点周围提取具有固定测地线半径（例如9 Å或12 Å）的重叠径向面片。
    - **指纹计算**: 一个利用测地线卷积的几何深度神经网络处理这些面片，为每个表面点计算一个描述符（指纹）。

  - **Python/脚本流程**: MaSIF采用一个复杂的流程，涉及多个外部工具和Python库：`reduce`（用于PDB结构质子化）、`MSMS`（用于分子表面三角化）、`BioPython`（用于解析PDB文件）、`PyMesh`（用于处理.ply表面文件、属性和网格正则化）、`PDB2PQR`和`APBS`（用于计算泊松-玻尔兹曼静电势以导出电荷特征）、`open3D`（用于RANSAC对齐等任务）以及`Tensorflow`（作为深度学习框架）[^92]。

  - **代码**: MaSIF框架可在GitHub上的`LPDI-EPFL/masif`获取[^1]。`data_preparation`目录包含协调这些步骤的脚本（例如`data_prepare_one.sh`）。

- PINet (Protein Interface Network) (Gainza et al., 2020)

  :

  - **方法**: PINet是一个几何深度神经网络，旨在预测蛋白质相互作用界面区域。它以编码两个伴侣蛋白结构的点云对作为输入[^98]。
  - 该模型学习捕捉几何和理化分子表面的互补性，以预测相互作用区域[^99]提到PINet在点云上使用PointNet。
  - 综述[^1]将PINet列在MaSIF下，表明它们在表面/点云上的几何深度学习方面存在概念联系或共享基础。

#### 4. 三维点云表征

这种方法直接将分子表示为三维空间中的一组点（通常是原子），其中每个点都与一个特征向量（例如，坐标、原子类型、电荷）相关联。然后使用像PointNet这样的网络或专门的图神经网络来处理这个无序点集。

- Wang Y. et al. (Briefings in Bioinformatics 2022, "A Point Cloud-Based Deep Learning Strategy for Protein-Ligand Binding Affinity Prediction")

  :

  - **方法**: 这项工作将PointNet和PointTransformer架构直接应用于从蛋白质-配体复合物派生的三维点云，用于结合亲和力预测[^101]。

  - 点云生成

    :

    - 对蛋白质-配体复合物（来自PDBbind）进行预处理（去除溶剂/金属/离子）。
    - 坐标对齐到配体的中心以减轻平移方差。
    - 选择距离配体中心最近的1024个原子。
    - 每个原子（点）由6个特征描述：x, y, z坐标、范德华半径、原子量和一个来源标识符（蛋白质为1，配体为-1）。
    - 特征进行归一化。如果原子少于1024个，则用零特征点填充该集合。

  - **工具**: 使用Python和OpenBabel进行初始点云生成，并使用C++加速此预处理步骤[^106]。

- PGpocket (Zhao, He, Wang et al., 2024)

  :

  - 尽管是另一个“Wang et al.”团队的不同工作，PGpocket也使用点云。它将蛋白质表面抽象为一个点云，为每个点提取几何和化学特征，然后构建一个点云图。随后应用GNN来预测结合位点[^102]。这说明了点云GNN在结构生物信息学中日益增长的兴趣。

三维表征的选择——无论是快照、体素、表面还是点云——反映了在信息内容、计算可行性以及与各种神经网络架构的兼容性之间进行权衡的不同策略。虽然提供了更丰富的空间信息，但与二维方法相比，这些方法通常伴随着更高的计算成本和数据准备复杂性。特征工程也仍然至关重要，无论是在定义体素通道内容，还是在将化学和几何特性映射到表面或点上。

### B. 基于三维表征的CNN架构与应用

CNN架构的选择与所使用的三维表征类型密切相关。

- **对于三维体素网格**: 标准的**三维CNN**是自然的选择。它们将二维CNN的原理扩展到三维卷积滤波器、三维池化层和全连接层。例如DeepSite、Pafnucy和AtomNet，它们使用此类架构从蛋白质-配体复合物或蛋白质结合位点的体素化表示中学习特征。
- **对于三维表面和网格**: 采用**几何深度学习（GDL）**模型。例如，MaSIF使用测地线卷积，这种卷积专门设计用于在曲面和网格上操作，通过在局部表面面片上定义类似卷积的操作来实现[^92]。
- **对于三维点云**: 使用专门的GDL架构，如**PointNet**[^106]和**PointTransformer**[^106]。这些网络旨在处理三维空间中的无序点集，学习对输入点排列不变的特征。适用于点云的GNN（如PGpocket[^102]）也很常见。PINet也利用了点云处理[^99]。

**应用领域**:

- **结合亲和力预测**: 一个主要应用，工具如Pafnucy[^71]、AtomNet[^60]、Ragoza等人的方法[^63]以及Wang Y.等人的PointNet/PointTransformer方法[^106]旨在预测蛋白质-配体相互作用的强度。
- **结合位点预测**: 识别配体或其他分子可能在蛋白质表面结合的位置。例如DeepSite[^66]、KDEEP、Ligdream和MaSIF-site[^92]。
- **QSAR、毒性和一般性质预测**: Deepsnap使用三维快照图像，应用于QSAR和毒性预测[^1]。
- **一般药物发现和筛选**: 许多三维方法通过提供结构见解，为虚拟筛选和识别新型候选药物的更广泛目标做出贡献。

### C. 三维方法的Python包和代码实现

三维分子图像生成和处理流程涉及多种Python包和外部软件。

- 构象生成

  :

  - **RDKit**: 广泛用于从SMILES或二维结构生成三维构象，常采用ETKDG（基于实验扭转角的知识距离几何）等算法[^3]。
  - **CORINA Classic**: 一种用于从二维结构或SMILES生成单个低能三维构象的软件，在DeepSnap工作流程中使用[^53]。

- 可视化和快照生成

  :

  - **Maestro (Schrödinger)**: 用于分子建模和可视化的商业软件，用于生成三维构象的多角度二维快照[^1]。
  - **PyMOL**: 一个开源的分子可视化系统，可通过Python高度脚本化。VideoMol使用它将旋转的构象渲染成帧[^107]。
  - **Jmol**: 一个用于三维化学结构的开源Java查看器，在最初的DeepSnap (Uesawa) 方法中用于可视化和捕获旋转的模型[^54]。

- 体素化工具

  :

  - **libmolgrid**: (`gnina/libmolgrid` on GitHub) 一个C++/CUDA库，带有Python绑定，用于创建体素化的分子数据，支持各种原子类型方案和GPU加速。关键类包括`ExampleProvider`, `GridMaker`和`AtomTyper`[^63]。
  - **DeepChem**: (`deepchem/deepchem` on GitHub) 提供`RdkitGridFeaturizer`，用于将蛋白质-配体复合物特征化为三维网格，具有可定制的特征和数据增强选项[^85]。
  - **MolVoxel**: (`SeonghwanSeo/molvoxel` on GitHub) 一个Python分子体素化工具，支持不同的密度类型和计算后端（NumPy, Numba, PyTorch/CUDA）[^89]。
  - **NEARL**: (`miemiemmmm/Nearl` on GitHub) 一个Python流程，专注于从MD轨迹中提取动态特征到三维体素表示，用于三维CNN[^90]。

- 表面处理工具 (主要用于MaSIF)

  :

  - **MSMS**: 用于计算溶剂排除表面（三角化网格）的外部命令行工具[^92]。
  - **PyMesh**: 用于处理和正则化表面网格的Python库[^92]。
  - **APBS (Adaptive Poisson-Boltzmann Solver)**: 用于计算分子表面静电势的外部工具[^92]。
  - **PDB2PQR**: 用于通过分配电荷和半径来准备APBS计算的蛋白质结构的外部工具[^92]。
  - **reduce**: 为PDB结构添加氢原子[^92]。

- 点云处理

  :

  - **OpenBabel**: 可用于生成点云数据的预处理步骤，如Wang Y.等人的工作所示[^106]。

- 深度学习框架

  :

  - **TensorFlow**: MaSIF[^92]和Pafnucy（Keras API）[^76]使用。
  - **PyTorch**: 日益普及，ImageMol[^13]和KekuleScope[^22]（尽管主要用于二维模型）使用。许多现代GDL库也基于PyTorch（例如，PyTorch Geometric，DeepChem与之集成[^55]）。

三维表示的多样性——快照、体素、表面和点云——反映了为机器学习寻找编码复杂三维分子信息的最佳方式的持续努力。每种方法都在信息密度、计算成本以及它们最适合的神经网络架构类型之间呈现出一组独特的权衡。虽然三维方法具有捕捉二维中经常丢失的关键空间细节的潜力，但它们通常需要比二维方法更多的计算资源，并依赖于高质量三维结构数据的可用性，例如蛋白质数据库（PDB）中的数据。

## IV. 分子序列和视频表征

除了静态的二维和三维图像，一些新兴方法试图捕捉分子的动态方面，或以类图像格式利用基于序列的信息供CNN处理。

### A. 分子视频/序列的生成

#### 1. 分子视频 (例如 VideoMol)

分子视频的概念旨在将分子的构象灵活性或动态特性表示为一个图像帧序列，从而提供比单个静态构象更丰富的输入。

- VideoMol (Zeng, Xiang et al.)

  : 这是一个基于分子视频的基础模型的显著例子[^107]。

  - 方法论

    :

    - **构象生成**: 该过程从生成三维构象开始。对于其预训练数据集，VideoMol利用了PCQM4Mv2数据库中的构象。对于下游任务中可能不易获得构象的情况，他们采用RDKit的`MMFFOptimizeMolecule()`函数和MMFF94力场来生成构象[^107]。
    - **旋转和快照生成**: 每个三维构象围绕正X、Y和Z轴进行系统的逆时针旋转。此过程为每个分子生成 $n_f=60$ 个快照（帧）。旋转角度由一个旋转矩阵 $R_z(\phi)$ 形式化，其中 $\phi = \pi/10$[^107]。
    - **渲染**: 这60个快照中的每一个都使用PyMOL渲染成分子帧，尺寸为224x224像素。使用特定的PyMOL命令确保描绘风格的一致性，例如 `bg_color white; hide (hydro); set stick_ball,on; set stick_ball_ratio,3.5; set stick_radius,0.15; set sphere_scale,0.2; set valence,1; set valence_mode,0; set valence_size, 0.1`[^107]。PyMOL最初生成640x480的帧，然后进行后处理（填充和调整大小）到最终的224x224尺寸[^107]。
    - **视频拼接**: 然后将60个渲染帧按顺序拼接在一起，形成最终的分子视频 $V = {v_1, v_2, ..., v_{n_f}}$，其中每个 $v_i \in \mathbb{R}^{3 \times 224 \times 224}$ （假设为3个颜色通道）[^107]。

  - Python包/脚本

    :

    - **RDKit**: 用于三维构象生成（如果尚未提供）[^107]。
    - **PyMOL**: 用于将旋转的构象渲染成单独的图像帧。PyMOL可通过Python高度脚本化，从而自动化旋转和帧保存过程。PyMOL命令如`mset`（定义电影帧/长度）、`rotate`（或手动旋转后使用`mview store`）和`mpng`（将帧保存为PNG）是此类工作流程的基础[^109]。

#### 2. 基于SMILES的序列/矩阵表示 (再访)

虽然在二维部分已讨论过，但有必要重申，一些方法以一种虽然在视觉上不是图像，但结果是适用于CNN的二维矩阵的方式处理SMILES字符串，从而以“类图像”的方式处理序列。

- **Hirohara M. et al.**: 将SMILES字符串转换为“SMILES特征矩阵”（例如，固定大小如400x42），其中行可能表示字符位置，列表示one-hot编码的字符或派生特征。然后将此矩阵输入到二维CNN[^36]。
- **BESTox**: 将SMILES转换为“二维二元矩阵”，编码了原子类型、键合氢数量、电荷、化合价、环信息、芳香性、手性和杂化状态等在SMILES字符串上的出现情况。此矩阵作为CNN输入[^1]。
- **MolPMoFiT (Li, Fourches)**: 此方法虽然在综述[^1]中列于自监督学习下，但主要在标记化的SMILES序列（原子级或SMILES对编码 - SPE）上使用NLP启发的架构（ULMFiT改编）[^119]。它更像是一种序列建模方法，而不是视觉意义上的基于图像的方法。

### B. 基于视频/序列数据的CNN架构与应用

- VideoMol

  :

  - 其架构可能涉及为视频处理设计的CNN。这些可以包括将第三维处理时间序列帧的三维CNN，或混合架构如CNN-LSTM，其中CNN从每个帧中提取空间特征，而LSTM对跨帧的时间依赖性进行建模。VideoMol论文提到使用“视频编码器”提取潜在特征，并实施自监督预训练策略，通过考虑构象动态变化和理化信息来优化这些表示[^113]。
  - **应用**: 预测分子靶点和性质，识别抗病毒分子。一个关键目标是有效地理解和利用分子的三维结构动力学[^107]。

- SMILES矩阵方法 (Hirohara, BESTox)

  :

  - 这些通常采用标准的二维CNN。卷积滤波器从SMILES字符串的二维矩阵表示中学习局部模式，这些模式可能对应于化学基序或特征之间的顺序关系[^36]。

- MolPMoFiT

  :

  - 使用Transformer或类似LSTM的架构，这些是NLP中用于序列建模的标准架构，而不是在视觉图像或类图像矩阵上操作的CNN[^119]。

### C. Python包和代码实现

- VideoMol

  :

  - 利用RDKit进行构象生成，PyMOL（可通过Python脚本化）将旋转的构象渲染成帧[^107]。在提供的摘要中未提供完整的VideoMol框架本身的公开GitHub链接。

- Hirohara M. et al.

  :

  - 其基于SMILES的CNN的源代码，用Chainer深度学习框架实现，据称可在 `http://www.dna.bio.keio.ac.jp/smiles/` 获取[^123]。

- BESTox

  :

  - 摘要中未提供明确的公开代码链接[^37]。

- MolPMoFiT

  :

  - 实现可在GitHub上的`XinhaoLi74/MolPMoFiT`获取[^119]。它使用PyTorch和Fastai库[^119]。

像VideoMol这样的分子视频的引入标志着朝着捕捉分子动力学迈出了重要一步，这些动力学通常对理解生物活性至关重要，但在静态二维或单构象三维图像中会丢失。这种方法允许模型从更丰富、时间分辨的分子结构表示中学习。然而，此类视频数据（例如VideoMol中每个分子60帧）的生成和处理计算量大，可能限制了它们目前与静态图像方法相比的广泛采用。将CNN应用于SMILES字符串的矩阵表示也展示了这些网络超越纯视觉数据的多功能性，突出了如果顺序信息可以结构化为局部模式有意义的二维网格，CNN就可以有效地应用。

## V. 多模态及其他相关方法

为了进一步增强分子系统的预测能力和理解，研究人员越来越多地探索多模态学习、迁移学习和自监督/无监督学习范式，通常将基于图像的表示与其他数据类型集成或利用大型未标记数据集。

### A. 多模态学习方法

多模态学习旨在同时从多种类型的数据（如图像、文本和图）中学习，以构建更全面、更准确的模型[^1]。基本前提是不同的模态捕获关于分子的互补信息，它们的融合可以导致模型性能的协同改进。

- Multi-modal (Wang et al. in [^1])

  :

  - **方法**: 该系统专注于通过处理从化学专利中提取的文本描述和结构图像来进行化学信息重建。它采用双分支模型架构：一个分支使用CNN进行图像处理，另一个分支使用BiLSTM+CRF进行文本处理。输出被对齐以识别异构化学实体及其关系[^1]。
  - **应用**: 主要用于通过理解和链接来自不同专利数据源的信息来生成大规模的近药物化合物库。

- MCNN-DDI (Asfand-E-Yar M. et al., 2024)

  :

  - **方法**: 一种为预测药物间相互作用（DDI）相关事件而设计的多模态CNN。它利用四个不同的CNN子模型，每个子模型专用于所涉及药物的特定特征类型：化学子结构（表示为从SMILES派生的相似性矩阵，而非直接的视觉图像）、酶、通路和药物靶点。然后组合这些子模型的输出以进行最终的DDI事件预测[^1]。
  - **代码**: 虽然论文发表在Scientific Reports[^125]，但摘要中未提供直接的公开代码链接。

- MultiDTI (Zhou et al.)

  :

  - **方法**: 该模型通过采用在异构网络上操作的联合学习框架来预测药物-靶点相互作用。它整合了来自这些网络的相互作用或关联信息以及药物和靶点的序列信息。一个关键方面是它能够将药物、靶点、副作用和疾病节点映射到一个共同的潜空间中。这使得MultiDTI能够通过基于其化学结构将其映射到这个学习到的空间中来预测新化学实体的相互作用[^1]。
  - **代码**: 可在GitHub上的`Deshan-Zhou/MultiDTI`获取[^1]。

- ISMol (Zhang, Xiang et al., 2024)

  :

  - **方法**: ISMol代表基于图像和序列的双视角学习用于分子性质预测。它利用交叉注意力机制来有效融合从分子的两个不同视角提取的信息：其二维图像和其SMILES字符串表示[^128]。
  - **代码**: 论文和代码的链接可在GitHub仓库`Shihang-Wang-58/papers_for_molecular_representation`中找到[^128]。

- CGIP (Wang et al., 2023)

  :

  - **方法**: CGIP，即对比图文预训练（Contrastive Graph-Image Pre-training），是一个用于分子表征学习的框架。它旨在将化学知识从分子图（显式编码连接性）迁移到分子图像（隐式编码结构）。这是通过在大量未标记分子上精心设计的模态内和模态间对比学习目标来实现的[^128]。
  - **代码**: 论文和代码的链接可在`Shihang-Wang-58/papers_for_molecular_representation`中找到[^128]。

越来越多地采用多模态方法反映了人们日益认识到没有任何单一的表征能够捕获分子的所有相关方面。通过将来自图像的视觉信息与来自SMILES的顺序信息、来自图的显式连接性或来自文本的上下文信息相结合，这些模型旨在实现更全面、更稳健的理解，从而可能带来准确性和泛化能力的提高。

### B. 基于图像模型中的迁移学习

迁移学习涉及重用从一个任务或领域获得的知识来改进另一个（通常是目标）领域的学习，在目标领域中标记数据可能稀缺[^1]。由于生成大规模、高质量标记数据集的成本和精力很高，这在药物发现中尤其重要。

- Dalkiran et al. (in [^1])

  :

  - **方法**: 这项工作因采用迁移学习识别分子图像而受到关注[^1]。综述[^1]链接到一个GitHub仓库`cansyl/TransferLearning4DTI`，表明其专注于药物-靶点相互作用预测。一般的想法是使用在大型数据集（例如，通用图像或广泛的化学图像数据集）上预训练的模型作为特征提取器，或作为在新模型（在更具体、更小的数据集上训练）上的初始化点。摘要[^140]和[^141]讨论了DTI中的迁移学习，但并未具体说明此特定工作的图像生成。

- Li et al. (in [^1] - Lingqiao Li et al., 2020 JIOHS)

  :

  - **方法**: 该研究应用迁移学习，使用一维CNN处理近红外（NIR）光谱数据，进行多制造商药物识别。虽然输入是光谱数据而非分子结构图像，但它例证了当数据采集困难或标记成本高昂时，迁移学习在化学分析中的效用[^1]。利用预训练模型来提高在较小相关数据集上性能的核心原则是适用的。

- KekuleScope

  :

  - **方法**: 如前所述，KekuleScope扩展了现有的著名CNN架构（AlexNet, DenseNet-201, ResNet152, VGG-19），这些架构最初在大型、异构的图像数据集（如ImageNet）上进行了预训练。这种预训练使模型能够学习通用的视觉特征，然后针对从二维凯库勒结构表示预测化合物活性的特定任务进行微调[^1]。这是从通用领域到专门化学领域的经典迁移学习示例。

- MoleCLIP (Harnik et al., 2024, ChemRxiv)

  :

  - **方法**: 这项近期工作明确利用OpenAI的CLIP（对比语言-图像预训练）视觉基础模型作为分子图像表征学习框架的骨干。通过从一个强大的通用视觉模型开始，MoleCLIP证明它需要明显更少的分子特异性预训练数据就能达到或超过在分子数据上从头开始训练的最新模型的性能。这突出了将知识从非常大规模的通用视觉模型迁移到化学任务的潜力[^134]。

迁移学习通过有效利用预训练模型中封装的现有知识，解决了“小数据药物发现问题”[^1]。这减少了对每个新药物发现任务的大量标记数据集的依赖，并可以加速模型开发。

### C. 自监督和无监督学习

这些学习范式使模型能够从未标记的数据中学习有意义的表征，鉴于未标记化学数据的丰富性，这一点非常有利。

- ImageMol (Zeng, Xiang et al.)

  :

  - **方法**: ImageMol是一个专为分子图像设计的无监督/自监督预训练框架。它通过关注分子图像像素中存在的局部和全局结构特征，从一个包含1000万未标记类药化合物的大型数据集中学习化学表征[^13]。预训练可能涉及分子图像重建等任务，并且该框架可以整合各种代理任务，如对比学习或拼图游戏，正如[^1]中展示的通用迁移学习流程所示，ImageMol与此一致。ResNet18被提及作为预训练脚本的骨干网络[^13]。
  - **代码**: `HongxinXiang/ImageMol` on GitHub[^13]。

- MolPMoFiT (Li, Fourches)

  :

  - **方法**: 这种方法将自监督预训练应用于SMILES序列而非视觉图像。它改编了NLP中的ULMFiT（通用语言模型微调）方法。一个大规模分子结构预测模型在来自ChEMBL的一百万个未标记分子上使用标记化的SMILES（原子级或通过SMILES对编码 - SPE）进行预训练。然后将此预训练模型针对特定的QSAR任务进行微调[^119]。
  - **代码**: `XinhaoLi74/MolPMoFiT` on GitHub[^119]。

- 

特别是自监督学习，通过定义使模型能够学习数据内在特征的代理任务，允许模型利用大量未标记的分子数据（SMILES字符串或生成的图像）。然后可以将这种学习到的表征迁移到下游的监督任务中，通常会带来性能和数据效率的提高。这些方法的成功突显了利用大型未标记化学数据集构建强大的基础模型的价值。

这些先进学习范式——多模态学习、迁移学习和自监督学习——与基于图像的分子表征的融合，预示着未来AI模型将能够从化学数据中学习更丰富、更具泛化性、更细致的特征。这有望通过提高预测准确性、增强数据效率以及可能揭示新的化学见解，从而显著加快药物发现的步伐。

## VI. 总结与展望

本报告综述了将分子信息转换为适用于药物发现及相关化学科学领域卷积神经网络（CNN）应用的各种基于图像的表征方法。这些技术涵盖了二维图像、多方面的三维表征（快照、体素、表面、点云）以及新兴的分子视频/序列格式。

### A. 关键分子到图像方法与CNN应用回顾

- **二维表征**: 主要使用RDKit等工具从SMILES字符串生成，包括标准的凯库勒结构图和更高级的多通道图像（如Chemception），后者将化学特征直接编码到图像通道中。这些方法广泛应用于QSAR、ADMET预测、毒性筛选和DTI，通常使用标准的CNN架构。

- 三维表征

  :

  - **快照**: 三维构象在多个角度下的二维投影（例如，使用Maestro，或如Uesawa的Deepsnap中使用的Jmol）。
  - **体素**: 将原子存在或理化性质编码到离散化的三维网格中，由三维CNN处理（例如，AtomNet, DeepSite, Pafnucy, Ragoza等人的工作, Kuzminykh D.等人的工作）。libmolgrid和DeepChem的`RdkitGridFeaturizer`等库有助于此过程。
  - **表面**: 带有映射特征的分子表面，由几何深度学习（GDL）模型处理（例如，MaSIF, PINet）。
  - **点云**: 将原子直接表示为带特征的三维点，由PointNet/PointTransformer等网络处理（例如，Wang Y.等人的工作）。 这些对于基于结构的任务（如结合亲和力和位点预测）至关重要。

- **视频/序列表征**: 分子视频（例如，使用RDKit和PyMOL的VideoMol）旨在捕捉动力学。从SMILES派生的矩阵（例如，Hirohara M.等人, BESTox）以二维格式表示序列供CNN使用。

- **高级学习范式**: 多模态学习（结合图像与文本、图等）、迁移学习（利用预训练模型）和自监督学习（从未标记数据中学习）正在增强基于图像的方法的能力（例如，ImageMol, MolPMoFiT, MoleCLIP）。

### B. 不同表征模态的比较讨论

分子表征的选择并非一刀切；它涉及信息丰富度、计算成本和任务适用性之间的权衡。

- **二维图像**: 具有生成简单（尤其适用于大型SMILES数据库）和模型训练计算成本较低的优势。它们非常适合高通量筛选和主要由宏观结构特征决定的任务。然而，它们固有地丢失了可能至关重要的显式三维空间信息。多通道二维图像试图通过将更丰富的化学信息直接编码到图像平面中来弥补这一点[^1]。

- 三维表征

  : 提供对理解和预测蛋白质-配体结合等相互作用至关重要的显式空间信息。

  - **三维构象快照**提供了一种折衷方案，以比完整三维方法更低的计算成本为二维CNN提供一些三维视角，但视角有限。
  - **体素网格**是三维CNN的自然扩展，但可能存在数据稀疏和计算需求高的问题。分子在网格中的朝向如果不由数据增强或旋转不变架构处理，也可能影响结果。有效的体素通道特征工程至关重要[^66]。
  - **表面和点云表示**，由GDL模型处理，通常被认为更“自然”地适用于不规则的三维结构，可能避免一些体素化伪影。然而，GDL模型的开发和数据预处理流程（例如，MaSIF的流程[^92]）可能很复杂。

- **视频/序列表示**: 具有捕捉分子动力学和柔性的独特潜力，这些通常是生物功能的关键决定因素。VideoMol渲染旋转构象的方法是初步尝试[^107]。然而，这些方法目前在数据生成（例如，每个分子60帧）和模型训练方面计算需求最高。

### C. 当前挑战

尽管取得了显著进展，基于图像的分子表征学习领域仍存在一些挑战：

- **图像转换损失**: 将分子结构（尤其是三维结构映射到二维图像，甚至三维结构映射到离散网格）的过程可能导致关键信息的丢失或失真[^1]。
- **模型泛化能力**: 深度学习模型，特别是CNN，需要大量的训练数据。在特定数据集或特定终点上训练的模型，如果没有广泛的重新训练或复杂的领域自适应技术，可能难以很好地泛化到新的、未见过的化学空间或不同的生物靶点[^1]。
- **表征的可解释性**: 理解CNN为何从分子图像中做出特定预测仍然是一个重大障碍。虽然像类激活映射（CAM）和Grad-CAM这样的方法通过高亮有影响力的图像区域提供了一些见解，但增强这些“黑箱”模型的可解释性对于建立信任、推导新的科学假设和指导实验设计至关重要[^1]。这在药物发现中尤其重要，因为理解预测的机制或结构基础与预测本身同样有价值。
- **数据稀缺性和质量**: 高质量、标记的数据集，特别是对于三维结构（例如，共结晶的蛋白质-配体复合物）或动态分子数据，通常有限。这可能阻碍鲁棒且可泛化模型的训练。
- **计算成本**: 生成、存储和处理三维及基于视频的分子表征，以及训练相应的复杂神经网络架构，计算量可能很大，需要大量的GPU资源和时间。

### D. 未来方向

该领域正在迅速发展，有几个有前景的未来方向：

- **改进的三维表征**: 对开发更密集、信息更丰富且固有旋转/平移不变的三维输入表征的研究将继续。Kuzminykh D.等人提出的小波变换[^78]或学习到的等变表征等方法至关重要。
- **高级几何深度学习**: 为分子图、表面和点云开发更强大、更定制化的GDL架构，可能会在基于结构的新药设计任务中产生显著改进。
- **增强的多模态学习集成**: 预计将出现更复杂的方法，用于将图像数据与其他模态（图、序列、文本、组学数据、实验读数）融合。这可能涉及注意力机制、联合嵌入空间和协同训练策略，以利用不同数据源的互补优势[^128]。
- **化学基础模型**: 构建和利用在海量未标记化学图像或结构数据集上预训练的大规模基础模型（类似于NLP中的GPT或CV中ImageNet训练的模型）的趋势可能会加速。像ImageMol[^13]这样的模型以及像CLIP这样的通用视觉模型的应用（例如MoleCLIP[^134]）预示着这个方向。这些模型可以作为各种下游任务的强大起点，只需最少的微调。
- **整合分子动力学**: 超越静态快照或简单旋转，更有效地表示和学习真实的分子动力学（例如，从MD模拟中），是一个关键的前沿领域。虽然VideoMol[^107]和NEARL[^90]是朝这个方向迈出的步伐，但开发计算上易于处理的方法将丰富的动态信息输入CNN/GDL模型仍然是一个挑战。
- **自动化和标准化流程**: 开发用户友好的工具和标准化的流程，覆盖从分子输入到图像生成、特征提取、模型训练和解释的整个工作流程，对于更广泛的采用和可重复性至关重要。
- **增强的可解释性技术**: 继续研究专门针对化学图像和三维结构的模型可解释性方法，对于从这些复杂模型中提取可操作的科学见解至关重要。

基于图像的分子表征学习的发展历程证明了跨学科创新的力量，它大量借鉴了计算机视觉的成果，同时适应了化学数据的独特挑战。随着计算资源的增长和AI方法的日益复杂，这些视觉方法有望在加速新药发现和开发方面发挥越来越关键的作用。富含信息的图像数据与先进学习范式的融合，有望解锁对分子结构与生物功能之间复杂关系的更深刻见解。

## VII. 参考文献

*(一个正式报告会在此处根据统一的引文风格，如ACS或Nature风格，编纂一个基于所提供摘要的完整参考文献列表。)*

**部分关键参考文献 (基于所提供摘要的示例性列表):**

1. Li, Y., Liu, B., Deng, J., Guo, Y., Du, H. Image-based molecular representation learning for drug development: a survey. *Briefings in Bioinformatics*, **2024**, 25(4), bbae294.
2. RDKit: Open-Source Cheminformatics Software. `https://www.rdkit.org`
3. Riniker, S., Landrum, G. A. Better Informed Distance Geometry: Using What We Know To Improve Conformation Generation. **J. Chem. Inf. Model.** ***\*2011\**5**, 55, 12, 2562–2574.
4. RDKit Documentation: Molecular Drawing. `https://www.rdkit.org/docs/GettingStartedInPython.html#drawing-molecules`
5. RDKit Documentation: rdkit.Chem.Draw.rdMolDraw2D — RDKit documentation. `https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw2D.html`
6. RDKit Cookbook: Drawing molecules. `https://www.rdkit.org/docs/Cookbook.html#drawing-molecules`
7. Ma, B.,ደን λόViswanathan, U., Ji, H. F., & Willett, P. An evaluation of 2D fingerprint-based measures of similarity between small molecules for the prediction of protein targets. *Mol. Inf.* **2015**, 34, 104-110. (间接相关，说明特征提取的重要性)
8. (此处应为 MolDrawOptions.highlightAtomColors 或 DrawMolecule 中 highlightAtomColors 的具体 RDKit 文档或示例)
9. Pillow (PIL Fork) documentation. `https://pillow.readthedocs.io/`
10. RDKit Documentation: rdkit.Chem.Draw.MolDrawOptions — RDKit documentation. `https://www.rdkit.org/docs/source/rdkit.Chem.Draw.MolDrawOptions.html`
11. Wildcard Consulting Blog (David Hall). Chemception: Going from Molecules to Images in RDKit. `https://wildcardconsulting.dk/chemception-going-from-molecules-to-images-in-rdkit/` (2018). (引用文献中的博客)
12. Rifaioglu, A.S., Nalbat, E., Atalay, V., Doğan, T., Martin, M.J., Cetin-Atalay, R., Atalay, V. DEEPScreen: high performance drug–target interaction prediction with convolutional neural networks using 2-D structural compound representations. *Chemical Science*, **2020**, 11, 2531–2557.
13. Zeng, X., Xiang, H., Yu, L., Wang, J., Wang, Y., Liu, B., Li, K., Cheng, F. Accurate prediction of molecular properties and drug targets using a self-supervised image representation learning framework. *Nature Machine Intelligence*, **2022**, 4, 960–972.
14. Goh, G.B., Siegel, C., Vishnu, A., Hodas, N.O., Baker, N.A. Chemception: A Deep Neural Network with Minimal Chemistry Knowledge Matches the Performance of Expert-developed QSAR/QSPR Models. *arXiv:1706.06689*, **2017**. (后续发表于 *J. Comput. Chem.*)
15. (同14)
16. (RDKit DrawingOptions.dotsPerAngstrom 的具体文档或示例)
17. (RDKit MolDrawOptions.setAtomPalette 的具体文档或示例)
18. (同11, 14)
19. Goh, G. B., Hodas, N. O., & Vishnu, A. Deep learning for computational chemistry. *J. Comput. Chem.* **2017**, 38, 1291-1307.
20. GitHub repository: `https://github.com/Abdulk084/Chemception` (Chemception Keras/TensorFlow 实现示例)
21. Cortés-Ciriano, I., Bender, A. KekuleScope: prediction of cancer cell line sensitivity and compound potency using convolutional neural networks trained on compound images. *Journal of Cheminformatics*, **2019**, 11, 41.
22. GitHub repository: `https://github.com/isidroc/kekulescope` (KekuleScope PyTorch 实现)
23. Fernandez, M., Ban, F., Woo, G., Hsing, M., Yamazaki, T., LeBlanc, E., Rennie, P.S., Welch, W.J., Cherkasov, A. Toxic Colors: The Use of Deep Learning for Predicting Toxicity of Compounds Merely from Their Graphic Images. *Journal of Chemical Information and Modeling*, **2018**, 58(8), 1533–1543.
24. (此处应为 ADMET-CNN 的主要参考文献)
25. Shi, T., Yang, Y., Huang, S., Catana, C., Zheng, M. Molecular image-based convolutional neural network for the prediction of ADMET properties. *Chemometrics and Intelligent Laboratory Systems*, **2019**, 194, 103853.
26. (此处应为 QSAR-CNN (Zhong et al.) 的主要参考文献)
27. Zhong, R., Lv, M., Zhou, P., Li, C., Li, J., Yang, H., & Chen, J. (2021). QSAR-CNN: A novel method for predicting the reactivity of organic contaminants with OH radicals. *Water Research*, 190, 116722. (根据综述内容推测)
28. (此处应为 Hirohara M. et al. 的主要参考文献)
29. Hirohara, M., Saito, Y., Koda, Y., Sato, K., & Sakakibara, Y. (2018). Convolutional neural network based on SMILES representation of compounds for detecting chemical moti2f. *BMC Bioinformatics*, 19(S19), 525. (根据综述内容推测)
30. (此处应为 BESTox 的主要参考文献)
31. Zhao, Q., Xia, J., Hu, J., Yin, Z., & Liu, S. (2019). BESTox: a 2D SMILES-based deep learning method for acute oral toxicity prediction. *Journal of Cheminformatics*, 11(1), 1-12. (根据综述内容推测)
32. (此处应为 ResNet18DNN 的主要参考文献)
33. Zhao, J., Liu, P., Li, H., Li, S., Zhang, B., Feng, Y., ... & Wang, Y. (2021). ResNet18DNN: a residual neural network for prediction of drug-induced liver injury. *Briefings in Bioinformatics*, 22(5), bbab056. (根据综述内容推测)
34. Liu, P., Li, H., Li, S., Lv, H., Gong, J., Liu, H., Wang, Y. Improving prediction of phenotypic drug response on cancer cell lines using deep convolutional network. *BMC Bioinformatics*, **2019**, 20, 241.
35. Asilar, E., Hemmerich, J., Ecker, G.F. Image Based Liver Toxicity Prediction. *Journal of Chemical Information and Modeling*, **2020**, 60(3), 1111–1121.
36. (同29)
37. (同31)
38. (同33)
39. GitHub repository: `https://github.com/Lowpassfilter/tCNNS-Project` (tCNNs 实现)
40. (DILI预测相关文献，可能涉及指纹和CNN)
41. (同34)
42. (OpenBabel 相关文献或网站: `http://openbabel.org`)
43. (Schrödinger Maestro 软件信息: `https://www.schrodinger.com/products/maestro`)
44. (Deepsnap (Uesawa) 的相关文献或 Jmol: `http://jmol.sourceforge.net/`)
45. Matsuzaka, Y., Uesawa, Y. Optimization of a deep-learning method based on the classification of images generated by parameterized deep snap a novel molecular-image-input technique for quantitative structure–activity relationship (QSAR) analysis. *Frontiers in Bioengineering and Biotechnology*, **2019**, 7, 65.
46. (RDKit MolDraw3D 文档: `https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw3D.html`)
47. (AtomNet 的原始文献: Wallach, I., Dzamba, M., & Heifets, A. (2015). AtomNet: A Deep Convolutional Neural Network for Bioactivity Prediction in Structure-based Drug Discover3y. *arXiv:1510.02855*)
48. (Ragoza et al. 关于体素化的文献，可能与GNINA相关)
49. Ragoza, M., Hochman, J., St-Maurice, J. P., & Koes, D. R. (2017). Ligand pose optimization with atomic grid-based potentials. *Journal of Chemical Information and Modeling*, 57(4), 942-957. (与libmolgrid相关)
50. (DeepSite 的原始文献: Jimenez, J., Doerr, S., Martinez-Rosell, G., Rose, A. S., & De Fabritiis, G. (2017). DeepSite: protein-binding site predictor using 3D-convolutional neural networks. **Bioinformatics**, 33(19), 30346-3042.)
51. (KDEEP 的原始文献: Jiménez, J., Škalič, M., Martínez-Rosell, G., & De Fabritiis, G. (2018). KDeep: Protein–Ligand Binding Affinity Prediction with 3D Convolutional Neural Networks. *J. Chem. Inf. Model.*, 58(2), 287-296.)
52. (Pafnucy 的原始文献: Stepniewska-Dziubinska, M.M., Zielenkiewicz, P., Siedlecki, P. Development and evaluation of a deep learning model for protein–ligand binding affinity prediction. *Bioinformatics*, **2018**, 34(21), 3666–3674.)
53. GitHub repository: `http://gitlab.com/cheminfIBB/pafnucy` (Pafnucy 代码)
54. Kuzminykh, D., Kadurin, A., Zhebrak, A., Baskov, I., Nikolenko, S., Shayakhmetov, R., Zhavoronkov, A. 3D Molecular Representations Based on the Wave Transform for Convolutional Neural Networks. *Molecular Pharmaceutics*, **2018**, 15(10), 4516–4521.
55. GitHub repository: `https://github.com/gnina/libmolgrid` (libmolgrid 代码)
56. (DeepChem RdkitGridFeaturizer 文档: `https://deepchem.readthedocs.io/en/latest/api_reference/featurizers.html#rdkitgridfeaturizer`)
57. GitHub repository: `https://github.com/deepchem/deepchem` (DeepChem 代码)
58. (MolVoxel 相关信息: `https://github.com/SeonghwanSeo/molvoxel`)
59. (NEARL 相关信息: `https://github.com/miemiemmmm/Nearl`)
60. (MaSIF 的原始文献: Gainza, P., Sverrisson, F., Monti, F., Rodolà, E., Boscaini, D., Bronstein, M.M., Correia, B.E. MaSIF: an open-source tool based on geometric deep learning for search and design of molecular surface interactions. *Nature Methods*, **2020**, 17, 182–191.)
61. GitHub repository: `https://github.com/LPDI-EPFL/masif` (MaSIF 代码)
62. (PINet 的原始文献: Gainza, P., et al. (2020). Deciphering interaction fingerprints from protein molecular surfaces using geometric deep learning. **Nature Methods**, 17(2), 1582-191. 注意这篇文献与MaSIF是同一篇，PINet是其应用之一或相关后续。)
63. (PointNet 的原始文献: Qi, C. R., Su, H., Mo, K., & Guibas, L. J. (2017). Pointnet: Deep learning on point sets for 3d classification and segmentation. **Proceedings of the IEEE conference on6\* *computer vision and pattern recognitio7\*n.*)
64. Wang, Y., Sun, S., Li, Z., Liu, F., & Zheng, W. (2022). A point cloud-based deep learning strategy for protein-ligand binding affinity prediction. *Briefings in Bioinformatics*, 23(1), bbab429.
65. (PGpocket 的原始文献: Zhao, L., He, H., Wang, B., Liu, B., & Wang, S. (2024). PGpocket: predicting protein ligand binding sites with a pre-trained graph neural network model on point clouds. *Briefings in Bioinformatics*, 25(1), bbad424.)
66. (VideoMol 的主要参考文献，例如: Zeng, X., Xiang, H., Hou, L., Zhang, T., Wang, J., Wang, Y., Li, K., Cheng, F. Molecular video-based foundation model for drug discovery. *Nature Communications*, **2024**, 15, 123.)
67. (PyMOL 软件信息: `https://pymol.org/`)
68. (MolPMoFiT 的原始文献: Li, X., & Fourches, D. (2020). MolPMoFiT: A Universal Molecular Representation Learning Framework for Property Prediction. *Journal of Chemical Information and Modeling*, 60(10), 4539-4549.)
69. GitHub repository: `https://github.com/XinhaoLi74/MolPMoFiT` (MolPMoFiT 代码)
70. (MCNN-DDI 的原始文献: Asfand-E-Yar, M., et al. (2024). MCNN-DDI: A Multi-Modal Convolutional Neural Network Model for Predicting Drug-to-Drug Interaction Events. *Scientific Reports*, 14, XXXX. (具体文章号需查证))
71. (MultiDTI 的原始文献: Zhou, D., et al. (2020). MultiDTI: A general framework for predicting drug-target interactions based on graph embedding and heterogeneous network. *Briefings in Bioinformatics*, 21(5), 1829-1840.)
72. GitHub repository: `https://github.com/Deshan-Zhou/MultiDTI` (MultiDTI 代码)
73. (ISMol 和 CGIP 相关信息，如GitHub: `https://github.com/Shihang-Wang-58/papers_for_molecular_representation` 中引用的论文)
74. (Dalkiran/TransferLearning4DTI 的相关信息)
75. (Li et al. 2020 JIOHS 的具体文献)
76. Harnik, M., Alon, G., Nitzan, M., & Shalev-Shwartz, S. (2024). MoleCLIP: A molecular image representation learning framework based on CLIP. *ChemRxiv*. DOI: 10.26434/chemrxiv-2024-r1zxt (预印本)
77. (convAE / dmitrav/pheno-ml 的相关信息)

## VIII. 附录：工具与方法表

下表概述了本报告中讨论的关键分子到图像工具和方法，重点是它们的图像生成特性、底层技术、代码可用性以及在基于CNN的药物发现中的主要应用领域。

**表1：用于CNN应用的分子到图像工具和方法概述**

| **工具/方法名称 (主要参考文献)**                    | **输入分子格式**         | **输出图像类型**                 | **关键图像生成细节/参数**                                    | **核心Python库/软件**                                      | **公开代码链接**                                  | **主要CNN应用领域**              | **综述引用页/表** |
| --------------------------------------------------- | ------------------------ | -------------------------------- | ------------------------------------------------------------ | ---------------------------------------------------------- | ------------------------------------------------- | -------------------------------- | ----------------- |
| RDKit (通用)                                        | SMILES, MOL, SDF         | 2D图像 (PNG, SVG)                | 可自定义大小、分辨率 (`dotsPerAngstrom`)、高亮（原子、键、颜色）、图例、描绘风格（kekulization, 楔形键）。`MolToImage`, `MolDraw2DCairo`。 | RDKit, Pillow                                              | `https://github.com/rdkit/rdkit`                  | 通用化学信息学, 各种QSAR/ML      | p.3, 表4          |
| KekuleScope (Cortés-Ciriano & Bender, 2019) [^21]   | SMILES (来自ChEMBL)      | 2D凯库勒结构图像                 | 标准2D表示。使用预训练CNN (AlexNet, DenseNet, ResNet, VGG)。 | RDKit, PyTorch, Pillow                                     | `https://github.com/isidroc/kekulescope`          | 癌细胞系敏感性, 化合物效价       | p.5, 表3, 4       |
| Chemception (Goh et al., 2017) [^15]                | SMILES                   | 2D灰度或多通道图像               | 4通道示例: 键级, 原子序数, Gasteiger电荷, 杂化态。图像大小 (如80x80, 48x48)，分辨率 (如0.5 Å/像素)。通道编码化学特征。 | RDKit, Keras/TF, Pillow                                    | `https://github.com/Abdulk084/Chemception` (示例) | 毒性、活性、溶解性预测           | p.6, 表3, 4       |
| DEEPScreen (Rifaioglu et al., 2020) [^12]           | SMILES                   | 2D结构图像                       | 200x200像素, RDKit生成。规范朝向。省略手性。                 | RDKit, (DL框架)                                            | (方法在论文中，无直接代码链接)                    | 药物-靶点相互作用 (DTI) 预测     | p.5, 表3          |
| Toxic Colors (Fernandez et al., 2018) [^23]         | SMILES (推测)            | 2D化学草图                       | “简易2D草图”，颜色通道相关。细节在补充材料。                 | (CNN框架)                                                  | (细节在论文补充材料)                              | 毒性预测 (Tox21)                 | p.6, 表3          |
| ImageMol (Zeng, Xiang et al., 2022) [^13]           | 规范SMILES               | 2D图像                           | 224x224像素。`Smiles2Img`函数。使用ResNet18骨干的自监督预训练。 | RDKit, PyTorch                                             | `https://github.com/HongxinXiang/ImageMol`        | 分子性质, 药物靶点, 抗SARS-CoV-2 | p.8, 表3, 4       |
| ADMET-CNN (Shi et al., 2019) [^1]                   | SMILES/SDF (推测)        | 分子二维图像                     | 具体图像生成参数细节不多，但专注于ADMET性质。                | (CNN框架)                                                  | (无直接代码链接)                                  | ADMET性质预测                    | p.5, 表3          |
| QSAR-CNN (Zhong et al., 2021) [^1]                  | SMILES/SDF (推测)        | 分子图像                         | 用于预测污染物与OH自由基的反应性。应用了迁移学习和数据增强。Grad-CAM用于解释。 | (CNN框架)                                                  | (无直接代码链接)                                  | QSAR, 反应性预测                 | p.5, 表3          |
| ResNet18DNN (Zhao et al. in [^1]) [^38]             | 分子结构                 | (推测图像或特征图)               | 18层ResNet提取特征用于DILI预测。输入类型需查阅原文。综述列为基于图像。 | (DL框架)                                                   | (无直接代码链接)                                  | 药物性肝损伤 (DILI) 预测         | p.6, 表3          |
| tCNNs (Liu et al., 2019) [^1]                       | SMILES                   | 1D CNN on One-Hot SMILES矩阵     | 规范SMILES填充到统一长度，然后one-hot编码。(72通道 x 188长度)。矩阵列作为1D卷积通道。 | Python, (CNN框架)                                          | `https://github.com/Lowpassfilter/tCNNS-Project`  | 表型药物反应预测                 | p.7, 表4          |
| Maestro (3D快照) [^1]                               | 3D构象 (SDF)             | 2D快照图像 (多角度)              | 全局旋转 (如y轴, 8x45°)，每视角保存图像。原子颜色，键样式。  | Maestro (商业)                                             | (专有软件)                                        | 性质预测 (Asilar et al.)         | p.3               |
| Deepsnap (Uesawa Y., Matsuzaka Y.) [^1]             | SMILES / 3D构象          | 3D快照图像 (参数化, 多角度)      | CORINA生成3D坐标, Jmol/PyMOL球棍渲染, 360°旋转 (如45°步长), 256x256 PNG。可自定义原子颜色、键半径、像素大小。 | CORINA, Jmol/PyMOL, Python                                 | (此版本无公开代码链接)                            | QSAR, 毒性预测                   | p.6, 表3          |
| Pafnucy (Stepniewska-Dziubinska et al., 2018) [^76] | PDB/MOL2 (Prot-Lig)      | 3D体素网格                       | 20Å立方盒, 1Å分辨率。每个体素19个原子特征 (原子类型, 杂化, 价键, SMARTS属性, 电荷, 分子类型)。 | OpenBabel, Chimera, Python, TF/Keras                       | `http://gitlab.com/cheminfIBB/pafnucy`            | 蛋白质-配体结合亲和力            | 用户查询          |
| DeepSite (Jimenez et al., 2017) [^66]               | PDB (Protein)            | 3D体素网格                       | 1Å³体素, 8通道 (疏水, 芳香, H键供/受, +/-离子化, 金属, 排除体积) 基于AutoDock4原子类型。网格覆盖蛋白质+8Å缓冲。 | Python (推测), (CNN框架)                                   | `www.playmolecule.org` (服务器)                   | 蛋白质结合位点预测               | 用户查询          |
| MaSIF (Gainza et al., 2020) [^92]                   | PDB (Protein)            | 带指纹的3D表面面片               | MSMS表面上的测地线面片 (9Å或12Å半径)。几何 (形状指数, 曲率) 和化学 (电荷, H键, 疏水性) 特征。测地线CNN。 | MSMS, PyMesh, APBS, PDB2PQR, BioPython, open3D, Python, TF | `https://github.com/LPDI-EPFL/masif`              | PPI位点预测, 配体预测            | 用户查询          |
| PINet (Gainza et al., 2020) [^98]                   | PDB (蛋白对)             | 蛋白质结构的点云                 | 输入点云对。学习几何和理化表面互补性。使用类PointNet架构。   | Python, (GDL框架)                                          | (PINet本身代码链接不明显)                         | 蛋白质相互作用界面预测           | 用户查询          |
| VideoMol (Zeng, Xiang et al., 2024) [^107]          | SMILES/3D构象            | 分子视频 (2D帧序列)              | RDKit构象(MMFF94)。PyMOL旋转(X,Y,Z轴)并渲染60帧(224x224像素)。 | RDKit, PyMOL, Python, (视频CNN框架)                        | (VideoMol无公开代码链接)                          | 分子靶点和性质预测, 抗病毒药物   | 用户查询          |
| Kuzminykh D. et al. (2018) [^78]                    | SMILES/3D构象            | 3D体素网格 (小波变换平滑)        | 0.5Å网格, one-hot原子类型 (6-9通道)。小波变换卷积以减少稀疏性并改善特征传播。 | Python, (CNN框架)                                          | (无公开代码链接)                                  | 分子表征, 分类                   | 用户查询          |
| MultiDTI (Zhou et al.) [^126]                       | 异构网络数据, 药/靶序列  | (无直接图像生成, 映射到公共空间) | 结合网络信息和序列信息。使用联合学习框架。                   | Python, PyTorch, scikit-learn                              | `https://github.com/Deshan-Zhou/MultiDTI`         | 药物-靶点相互作用预测            | p.7, 表4          |
| Image-based CNN (Asilar et al., 2020) [^51]         | 3D构象 (SDF)             | 3D快照图像 (多角度)              | Maestro旋转3D构象 (y轴, 8x45°) 并捕获图像。颜色编码原子。图像尺寸64x64, 128x128, 192x192。COVER上采样。 | Maestro, Python (推测)                                     | (无直接代码链接)                                  | 肝毒性预测                       | p.6, 表3          |
| convAE (Dmitrenko et al.) [^91]                     | 2D癌细胞图像             | 图像的潜在特征向量               | 在1M癌细胞图像上训练的卷积自编码器 (非直接分子结构)。输入图像128x128。 | Python, (DL框架)                                           | `https://github.com/dmitrav/pheno-ml`             | 分析药物对癌细胞的效应           | p.5, 表4          |
| DeepChem (`RdkitGridFeaturizer`) [^85]              | 蛋白-配体文件 (PDB, SDF) | 3D体素网格                       | 以配体为中心的盒子。可自定义`box_width`, `voxel_width`。特征: 'ecfp', 'splif', 'sybyl', 'charge', 'hbond'等。`nb_rotations`用于增强。 | RDKit, DeepChem (Python)                                   | `https://github.com/deepchem/deepchem`            | 结合亲和力, 复合物性质           | 用户查询          |

*注意：表中部分工具（如Li et al., Dalkiran et al.）主要使用非图像输入（如光谱），或其针对分子结构的图像生成细节在提供的摘要中未详细说明。BESTox和Hirohara M. et al. 使用SMILES的矩阵表示而非视觉图像。此表主要关注那些以CNN图像生成为核心或细节清晰的方法。*