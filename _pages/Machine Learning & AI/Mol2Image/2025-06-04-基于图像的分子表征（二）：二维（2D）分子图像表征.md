---
title: "Image-based Molecular Representation (II): 2D Molecular Image Representations"
date: "2025-06-04"
tags: [2d-molecular-images, rdkit, molecular-representation, image-based-ml, computer-vision, smiles, drug-discovery]
---
# 基于图像的分子表征：二维（2D）分子图像表征

二维图像是分子最直接的视觉表征，通常源自SMILES字符串。它们具有简单和直观的特点，使其成为分子设计和分析，特别是高通量应用中一个引人注目的选择。**二维分子图像为CNN提供了更直接可用和信息更丰富的输入，旨在减轻网络学习基本化学特征的负担，从而可能带来性能或数据效率的提升**。

## 一、RDKit基础用法

**RDKit**是解析SMILES、生成二维坐标和渲染分子图像的主要库[1]。其GitHub仓库是 https://github.com/rdkit/rdkit 。RDKit是一个核心的开源化学信息学工具包，广泛用于将SMILES字符串转换为二维分子图像。

### 1.1 基础工作流程

一般的工作流程包括：
1. 解析SMILES字符串以创建RDKit Mol对象
2. 生成用于描绘的二维坐标
3. 将此布局渲染成图像格式，通常是Python中的PIL Image对象

### 1.2 关键RDKit模块和函数

#### 基础函数
- `Chem.MolFromSmiles()`：将SMILES字符串解析为RDKit Mol对象[2]
- `Draw.MolToImage()`：从Mol对象生成PIL Image，允许基本的自定义，如图像大小、kekulization和楔形键的显示[3]
- `rdDepictor.Compute2DCoords()`：生成用于描绘的2D坐标。使用`rdDepictor.SetPreferCoordGen(True)`有助于实现更一致的分子朝向[4]
- `AllChem.Compute2DCoords()`：另一种生成2D坐标的选择[5]

#### 高级绘图类
- `Draw.MolDraw2DCairo`：生成光栅图像（如PNG），提供更细致的绘图选项控制[6]
- `Draw.MolDraw2DSVG`：生成矢量图像，提供更细致的绘图选项控制[6]

### 1.3 CNN输入的关键参数和自定义

#### 图像大小
**一致性对CNN输入至关重要**：
- DEEPScreen使用200x200像素[7]
- ImageMol默认为224x224像素[8]
- Chemception通常使用80x80像素[9]
- RDKit的`MolToImage`接受一个`size`元组
- `MolDraw2DCairo`则在初始化时指定宽度和高度

#### 分辨率和细节
- `DrawingOptions.dotsPerAngstrom`（用于`MolToImage`）控制像素密度相对于分子大小的比例[10]
- `MolDrawOptions.fixedBondLength`可以固定键在图像中的像素长度，以实现一致的缩放[11]

#### 原子和键的高亮
- `highlightAtoms`和`highlightBonds`参数可用于`MolToImage`以及绘图类的`DrawMolecule`方法[3]
- `highlightColor`（用于`MolToImage`）或`MolDrawOptions.highlightColour`设置高亮颜色[3]
- `MolDrawOptions.atomColourPalette`或`MolDraw2D.DrawMolecule(highlightAtomColors={atom_index: (R,G,B)})`允许自定义特定原子的颜色[12]

#### 原子和键的颜色
- `MolDrawOptions.setAtomPalette({atom_index: (R,G,B)})`可以设置自定义的原子颜色调色板[11]
- RDKit Cookbook也展示了使用`useBWAtomPalette()`生成黑白图像的方法[13]

#### 图例(Legends)
- `DrawMolecule`中的`legend`参数**或`MolsToGridImage`中的`legends`参数可以添加文本注释[3]
- `MolDrawOptions`如`legendFontSize`和`legendFraction`控制图例外观[11]

### 1.4 基础代码示例

#### 基础MolToImage示例

```python
from rdkit import Chem
from rdkit.Chem.Draw import MolToImage

mol = Chem.MolFromSmiles("CN1C=NC2=C1C(=O)N(C(=O)N2C)C")  # Caffeine
img = MolToImage(mol, size=(256, 256))
# img.save("caffeine_2d.png")
```

#### MolDraw2DCairo带高亮示例

```python
from rdkit import Chem
from rdkit.Chem.Draw import rdMolDraw2D
from io import BytesIO  # 用于在内存中处理图像数据
# from PIL import Image  # 用于查看或保存图像

mol = Chem.MolFromSmiles("Cc1ccccc1O")  # o-cresol
# 高亮甲基所在的子结构
substructure = Chem.MolFromSmarts("c(C)O")  # 带有甲基和羟基的芳香碳
match = mol.GetSubstructMatch(substructure)

drawer = rdMolDraw2D.MolDraw2DCairo(300, 300)  # width, height

# 自定义原子颜色示例
atom_colors = {}
if match:
    for atom_idx in match:
        if mol.GetAtomWithIdx(atom_idx).GetSymbol() == 'O':
            atom_colors[atom_idx] = (1.0, 0.0, 0.0)  # 氧原子用红色
        elif mol.GetAtomWithIdx(atom_idx).GetSymbol() == 'C':
             atom_colors[atom_idx] = (0.0, 0.0, 1.0)  # 碳原子用蓝色

drawer.DrawMolecule(mol, highlightAtoms=match, highlightAtomColors=atom_colors, 
                   legend="o-cresol with substructure highlight")
drawer.FinishDrawing()
png_data = drawer.GetDrawingText()  # 获取PNG数据 (bytes)
# with open("o_cresol_highlighted.png", "wb") as f:
#     f.write(png_data)
```

## 二、具体方法和实现

### 2.1 ImageMol

#### 方法简介
ImageMol是一个基于分子图像的无监督预训练深度学习框架，用于计算化学药物发现[14]。该框架在1000万无标签的类药物生物活性分子上进行预训练，**结合了图像处理框架和全面的分子化学知识，以视觉计算方式提取精细的像素级分子特征**[15]。

**ImageMol的核心创新**：
1. 利用分子图像作为化合物的特征表示，具有高精度和低计算成本
2. 利用无监督预训练学习框架从1000万种具有多样生物活性的类药物化合物中捕获分子图像的结构信息

#### 预训练策略
ImageMol采用五种预训练策略来优化分子编码器的潜在表示[16]：
1. **Mask-based contrastive learning (MCL)**：对分子图像的16×16方形区域进行掩码，训练模型最小化掩码和未掩码图像提取的潜在特征之间的距离
2. **Molecular rationality discrimination (MRD)**：预测输入图像是否合理
3. **Jigsaw puzzle prediction (JPP)**：将图像分解为九个补丁，随机重排后预测正确顺序
4. **Image rotational prediction**：预测图像的旋转角度
5. **Contrastive learning**：学习相似分子的相似表示

#### 代码实现

**基础图像生成**：
```python
def smiles_to_image(smis, size=224, save_path=None):
    try:
        mol = Chem.MolFromSmiles(smis)
        img = Draw.MolsToGridImage([mol], molsPerRow=1, subImgSize=(size, size))
        if save_path is not None:
            img.save(save_path)
        return img
    except:
        return None
```

**完整的latent feature提取功能**：

```python
import os
import torch
import torchvision.transforms as transforms
import torchvision.models as models
from tqdm import tqdm
import requests
from rdkit import Chem
from rdkit.Chem import Draw

def download_pretrained_model(model_url, cache_dir=None, force_download=False):
    """
    下载并缓存预训练模型文件
    
    参数:
        model_url: 模型下载链接
        cache_dir: 缓存目录（默认为系统临时目录下的 imagemol_cache）
        force_download: 是否强制重新下载模型
    
    返回:
        model_path: 模型文件路径
    """
    if cache_dir is None:
        cache_dir = os.path.join(tempfile.gettempdir(), "imagemol_cache")
    os.makedirs(cache_dir, exist_ok=True)
    
    model_path = os.path.join(cache_dir, "ImageMol.pth.tar")
    
    if force_download or not os.path.exists(model_path):
        print("开始下载预训练模型...")
        download_file_from_google_drive(model_url, model_path)
        print(f"模型已下载到: {model_path}")
    
    return model_path

def load_pretrained_model(model_name="ResNet18", image_size=224, pretrained=False, model_url=None):
    """
    加载预训练模型（支持从本地或远程下载）
    
    参数:
        model_name: 模型架构名称 (ResNet18/ResNet34/ResNet50)
        image_size: 输入图像尺寸
        pretrained: 是否使用 PyTorch 官方预训练权重
        model_url: 自定义预训练权重下载链接
    
    返回:
        model: 加载好的模型
    """
    # 如果指定了自定义模型链接，则先下载
    if model_url:
        model_path = download_pretrained_model(model_url)
    else:
        model_path = None  # 使用官方预训练权重
    
    if model_name == "ResNet18":
        model = models.resnet18(pretrained=pretrained)
    elif model_name == "ResNet34":
        model = models.resnet34(pretrained=pretrained)
    elif model_name == "ResNet50":
        model = models.resnet50(pretrained=pretrained)
    else:
        raise ValueError(f"不支持的模型架构: {model_name}")
    
    # 如果提供了自定义模型路径，加载权重
    if model_path:
        try:
            checkpoint = torch.load(model_path, map_location=torch.device('cpu'))
            model.load_state_dict(checkpoint['model_state_dict'])
            print("=> 成功加载自定义预训练权重")
        except Exception as e:
            print(f"=> 加载预训练权重失败: {e}")
            print("尝试直接从 torchvision 加载官方预训练权重...")
            model = models.resnet18(pretrained=True)  # 示例回退到官方权重
    
    return model

def download_file_from_google_drive(url, destination):
    """
    从 Google Drive 下载文件（支持大文件）
    """
    file_id = url.split('/')[-2] if 'view' in url else url.split('/')[-1]
    base_url = 'https://docs.google.com/uc?export=download'
    
    session = requests.Session()
    response = session.get(base_url, params={'id': file_id}, stream=True)
    
    # 处理下载确认
    for key, value in response.cookies.items():
        if key.startswith('download_warning'):
            params = {'id': file_id, 'confirm': value}
            response = session.get(base_url, params=params, stream=True)
            break
    
    # 写入文件
    with open(destination, 'wb') as f:
        with tqdm(unit='B', unit_scale=True, unit_divisor=1024) as bar:
            for chunk in response.iter_content(32768):
                if chunk:
                    f.write(chunk)
                    bar.update(len(chunk))

# 示例：创建 ResNet18 模型并提取 latent feature
def smiles_to_latent(smiles, model, image_size=224):
    """
    将 SMILES 字符串转换为 latent feature
    """
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        raise ValueError(f"无法解析 SMILES: {smiles}")
    
    # 生成分子图像
    img = Draw.MolsToGridImage([mol], molsPerRow=1, subImgSize=(image_size, image_size))
    img_path = "temp_molecule.png"
    img.save(img_path)
    
    # 图像预处理
    transform = transforms.Compose([
        transforms.Resize((image_size, image_size)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])
    img_tensor = transform(Image.open(img_path).convert('RGB')).unsqueeze(0)
    
    # 提取 latent feature
    with torch.no_grad():
        embedding_layer = list(model.children())[:-1]
        embedding_model = torch.nn.Sequential(*embedding_layer)
        latent_feature = embedding_model(img_tensor).squeeze()
    
    return latent_feature

# 主程序
if __name__ == "__main__":
    # 1. 下载并加载模型
    model_url = "https://drive.usercontent.google.com/download?id=1wQfby8JIhgo3DxPvFeHXPc14wS-b4KB5&export=download&authuser=0"
    model = load_pretrained_model(
        model_name="ResNet18",
        model_url=model_url  # 使用自定义预训练权重
    )
    
    # 2. 示例 SMILES
    mol_smiles = "Cc1ccccc1O"  # 异丙苯酚
    latent = smiles_to_latent(mol_smiles, model)
    
    print(f"Latent feature shape: {latent.shape}")
    print(f"Latent feature sample: {latent[:5]}")
```

#### 代码说明和来源
- **原仓库**：https://github.com/HongxinXiang/ImageMol
- **主要文件**：`smiles2img_pretrain.py`和`dataloader/image_dataloader.py`
- **License**：MIT License
- **论文**：发表在Nature Machine Intelligence (2022)，题目为"Accurate prediction of molecular properties and drug targets using a self-supervised image representation learning framework"

### 2.2 Chemception

#### 方法简介
Chemception是受Google Inception-ResNet深度卷积神经网络启发开发的深度CNN，**仅使用分子2D图像进行化学性质预测，无需提供额外的显式化学知识，如基本概念（周期性）或高级特征（分子描述符和指纹）**[17]。

**Chemception的关键创新**：
1. **多通道图像表示**：将显式的化学特征直接编码到图像通道中，为神经网络提供更丰富、信息量更大的输入
2. **四通道编码方案**：每个通道编码不同的化学属性，使CNN能够"看到"特定位置的化学性质

#### 多通道表示方法
Chemception采用4通道图像方法，每个通道编码特定的化学信息[18]：
- **通道0**：编码键级（例如，单键为1.0，双键为2.0）
- **通道1**：编码原子序数
- **通道2**：编码原子杂化状态（例如，sp, sp2, sp3表示为数值）
- **通道3**：编码Gasteiger部分电荷

图像尺寸通常为80x80像素或48x48像素。

#### 代码实现

```python
import numpy as np
from rdkit import Chem
from rdkit.Chem import AllChem
import matplotlib.pyplot as plt

def chemcepterize_mol(mol, embed=20.0, res=0.5):
    """
    将RDKit分子对象转换为Chemception格式的多通道图像
    
    参数:
        mol: RDKit分子对象
        embed: 嵌入大小，控制图像的空间范围
        res: 分辨率，每像素对应的空间距离
    
    返回:
        vect: 形状为(dims, dims, 4)的numpy数组，包含4个通道的化学信息
    """
    dims = int(embed*2/res)
    
    # 复制分子并计算Gasteiger电荷
    cmol = Chem.Mol(mol.ToBinary())
    cmol.ComputeGasteigerCharges()
    AllChem.Compute2DCoords(cmol)
    coords = cmol.GetConformer(0).GetPositions()
    
    # 初始化4通道图像向量
    vect = np.zeros((dims, dims, 4))
    
    # 首先处理键信息（通道0）
    for i, bond in enumerate(mol.GetBonds()):
        bondorder = bond.GetBondTypeAsDouble()
        bidx = bond.GetBeginAtomIdx()
        eidx = bond.GetEndAtomIdx()
        bcoords = coords[bidx]
        ecoords = coords[eidx]
        frac = np.linspace(0, 1, int(1/res*2))
        
        for f in frac:
            c = (f*bcoords + (1-f)*ecoords)
            idx = int(round((c[0] + embed)/res))
            idy = int(round((c[1] + embed)/res))
            
            # 确保索引在图像范围内
            if 0 <= idx < dims and 0 <= idy < dims:
                vect[idx, idy, 0] = bondorder  # 保存键级到第一个通道
    
    # 处理原子信息（通道1-3）
    for i, atom in enumerate(cmol.GetAtoms()):
        idx = int(round((coords[i][0] + embed)/res))
        idy = int(round((coords[i][1] + embed)/res))
        
        # 确保索引在图像范围内
        if 0 <= idx < dims and 0 <= idy < dims:
            # 原子序数（通道1）
            vect[idx, idy, 1] = atom.GetAtomicNum()
            
            # Gasteiger电荷（通道3）
            try:
                charge = float(atom.GetProp("_GasteigerCharge"))
                vect[idx, idy, 3] = charge
            except:
                vect[idx, idy, 3] = 0.0
            
            # 杂化状态（通道2）
            hyptype = atom.GetHybridization().real
            vect[idx, idy, 2] = hyptype
    
    return vect

# 使用示例
def demo_chemception():
    """演示Chemception图像生成"""
    # 创建分子对象
    mol = Chem.MolFromSmiles("CCO")  # 乙醇
    
    # 生成Chemception图像
    v = chemcepterize_mol(mol, embed=10, res=0.2)
    print(f"图像形状: {v.shape}")  # 输出：(100, 100, 4)
    
    # 可视化前3个通道（模拟RGB图像）
    plt.figure(figsize=(12, 4))
    
    plt.subplot(1, 4, 1)
    plt.imshow(v[:, :, 0], cmap='viridis')
    plt.title('通道0: 键级')
    plt.colorbar()
    
    plt.subplot(1, 4, 2)
    plt.imshow(v[:, :, 1], cmap='viridis')
    plt.title('通道1: 原子序数')
    plt.colorbar()
    
    plt.subplot(1, 4, 3)
    plt.imshow(v[:, :, 2], cmap='viridis')
    plt.title('通道2: 杂化状态')
    plt.colorbar()
    
    plt.subplot(1, 4, 4)
    plt.imshow(v[:, :, 3], cmap='viridis')
    plt.title('通道3: Gasteiger电荷')
    plt.colorbar()
    
    plt.tight_layout()
    plt.show()
    
    return v

# demo_chemception()
```

#### 代码说明和来源
- **原仓库**：https://github.com/Abdulk084/Chemception
- **主要文件**：`chemcemption.ipynb`
- **License**：MIT License
- **论文**：Goh等人2017年发表的"Chemception: A Deep Neural Network with Minimal Chemistry Knowledge Matches the Performance of Expert-developed QSAR/QSPR Models"[17]

### 2.3 DEEPScreen

#### 方法简介
DEEPScreen是一个大规模药物-靶点相互作用(DTI)预测系统，用于早期药物发现，**使用深度卷积神经网络和化合物的2D结构表示作为输入**[19]。DEEPScreen的主要优势是在输入层使用现成的2D结构表示，而不是性能有限的传统描述符。

**DEEPScreen的特点**：
1. 对704个目标蛋白质进行训练（使用精心策划的生物活性数据）
2. 使用200x200像素的2D结构表示
3. 手性信息被省略（这是SMILES表示的局限性，而非图像生成过程的问题）
4. 生成了近2100万个新的DTI预测

#### 代码实现

```python
import os
import subprocess
from rdkit import Chem
from rdkit.Chem import Draw
from rdkit.Chem.Draw import DrawingOptions
import cairosvg

# 配置参数
IMG_SIZE = 200
training_files_path = "/path/to/training_files"  # 需要根据实际情况修改

def save_comp_imgs_from_smiles(tar_id, comp_id, smiles):
    """
    将分子的 SMILES 表示转换为图片
    
    参数:
        tar_id: 目标 ID
        comp_id: 化合物 ID
        smiles: 分子的 SMILES 字符串
    """
    # 创建分子对象
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        print(f"无法解析SMILES: {smiles}")
        return
    
    # 设置绘图选项
    DrawingOptions.atomLabelFontSize = 55
    DrawingOptions.dotsPerAngstrom = 100
    DrawingOptions.bondLineWidth = 1.5
    
    # 确保目标目录存在
    target_dir = os.path.join(training_files_path, "target_training_datasets", tar_id, "imgs")
    os.makedirs(target_dir, exist_ok=True)
    
    # 绘制分子为 SVG 图像
    svg_path = os.path.join(target_dir, f"{comp_id}.svg")
    Draw.MolToFile(mol, svg_path, size=(IMG_SIZE, IMG_SIZE))
    
    # 将 SVG 图像转换为 PNG 图像
    png_path = os.path.join(target_dir, f"{comp_id}.png")
    cairosvg.svg2png(url=svg_path, write_to=png_path)
    
    # 删除临时的 SVG 文件
    if os.path.exists(svg_path):
        subprocess.call(["rm", svg_path])
    
    print(f"已生成图像: {png_path}")

def batch_generate_images(tar_id, smiles_dict):
    """
    批量生成分子图像
    
    参数:
        tar_id: 目标ID
        smiles_dict: 字典，键为化合物ID，值为SMILES字符串
    """
    for comp_id, smiles in smiles_dict.items():
        try:
            save_comp_imgs_from_smiles(tar_id, comp_id, smiles)
        except Exception as e:
            print(f"生成图像失败 - 化合物ID: {comp_id}, SMILES: {smiles}, 错误: {e}")

# 使用示例
if __name__ == "__main__":
    # 示例数据
    tar_id = "CHEMBL286"
    smiles_data = {
        "CHEMBL1": "CCO",  # 乙醇
        "CHEMBL2": "CCOC",  # 乙醚
        "CHEMBL3": "CN1C=NC2=C1C(=O)N(C(=O)N2C)C",  # 咖啡因
    }
    
    # 生成图像
    batch_generate_images(tar_id, smiles_data)
```

#### 代码说明和来源
- **原仓库**：https://github.com/cansyl/DEEPScreen
- **主要文件**：`bin/data_processing.py`
- **License**：MIT License
- **论文**：发表在Chemical Science (2020)，题目为"DEEPScreen: high performance drug–target interaction prediction with convolutional neural networks using 2-D structural compound representations"[19]
- **依赖**：需要安装`rdkit`和`cairosvg`库

### 2.4 KekuleScope

#### 方法简介
KekuleScope采用"凯库勒结构表示"作为CNN的输入[20]。该方法专注于使用标准的分子结构图像进行性质预测，与其他方法的主要区别在于其对分子图像的特定处理方式。

#### 代码实现

```python
import os
import sys
from rdkit import Chem
from rdkit.Chem import Draw
import glob

def generate_molecule_images(cell_line, seed, smiles_list, chembl_ids, dataset_type):
    """
    生成分子图片的主函数
    
    参数:
        cell_line: 细胞系名称
        seed: 随机种子
        smiles_list: SMILES字符串列表
        chembl_ids: ChEMBL ID列表
        dataset_type: 数据集类型 ("train", "val", "test")
    """
    base_dir = f'./images/{cell_line}/{seed}/{dataset_type}/images'
    os.makedirs(base_dir, exist_ok=True)

    svgs = glob.glob(f"{base_dir}/*svg")
    pngs = glob.glob(f"{base_dir}/*png")
    
    # 如果没有SVG或PNG文件，则生成SVG图像
    if len(svgs) == 0 and len(pngs) == 0:
        for i, smiles in enumerate(smiles_list):
            mol = Chem.MolFromSmiles(smiles)
            if mol is not None:
                # 生成SVG图像
                svg_img = Draw.MolsToGridImage([mol], molsPerRow=1, useSVG=True)
                svg_file_path = f'{base_dir}/{chembl_ids[i]}.svg'
                with open(svg_file_path, 'w') as f:
                    f.write(svg_img.data)
                print(f"已生成SVG: {svg_file_path}")
            else:
                print(f"无法解析SMILES: {smiles}")
    else:
        print(f"SVGs ready for {dataset_type}")

    # 将 SVG 转换为 PNG
    pngs = glob.glob(f"{base_dir}/*png")
    if len(pngs) == 0:
        basedir = os.getcwd()
        os.chdir(base_dir)
        
        # 使用ImageMagick进行转换
        cmd = "AA=($( find . -name '*.svg'  ));for i in ${AA[*]}; do convert -density 800 ${i} -resize 300x ${i}.png ; done"
        try:
            os.system(cmd)
            print("SVG转PNG完成")
        except Exception as e:
            print(f"转换过程中出现错误: {e}")
        
        # 清理SVG文件
        cmd = "rm -rf *.svg"
        os.system(cmd)
        
        os.chdir(basedir)

def run_kekulescope_pipeline(cell_line="KB", seed=1):
    """
    运行完整的KekuleScope图像生成流程
    
    参数:
        cell_line: 细胞系名称，默认为"KB"
        seed: 随机种子，默认为1
    """
    # 示例数据
    smiles_list = [
        "CCO",  # 乙醇
        "CCOC",  # 乙醚
        "CN1C=NC2=C1C(=O)N(C(=O)N2C)C",  # 咖啡因
        "CC(C)CC1=CC=C(C=C1)C(C)C(=O)O",  # 布洛芬
    ]
    
    chembl_ids = ["CHEMBL1", "CHEMBL2", "CHEMBL3", "CHEMBL4"]
    
    # 为不同数据集生成图像
    for dataset_type in ["train", "val", "test"]:
        print(f"正在为{dataset_type}数据集生成图像...")
        generate_molecule_images(cell_line, seed, smiles_list, chembl_ids, dataset_type)

# 使用示例
if __name__ == "__main__":
    run_kekulescope_pipeline()
```

#### 代码说明和来源
- **原仓库**：https://github.com/isidroc/kekulescope
- **主要文件**：`Kekulescope.py`和`load_images.py`
- **License**：[MIT license](https://github.com/isidroc/kekulescope#MIT-1-ov-file)
- **框架**：利用PyTorch框架
- **特点**：使用ImageMagick进行SVG到PNG的转换，需要系统安装ImageMagick

### 2.5 其他相关方法

#### DECIMER 1.0
DECIMER (Deep lEarning for Chemical ImagE Recognition)是一个基于Transformer的光学化学结构识别工具[21]，**专注于从化学图像中识别和重构分子结构**。该工具使用CNN进行图像解析，然后使用Transformer解码器生成SMILES字符串。

- **GitHub**：https://github.com/Kohulan/DECIMER
- **特点**：使用EfficientNet-B3作为编码器，处理299×299像素图像
- **应用**：主要用于从文献中的化学结构图像提取SMILES表示

#### MolNexTR
MolNexTR是一个结合ConvNext和Vision Transformer的深度学习模型，**用于从分子图像生成SMILES字符串**[22]。该模型能够同时预测原子和键，并理解它们的布局规则。

- **特点**：结合CNN和Vision Transformer的优势
- **应用**：分子图像识别和SMILES生成
- **数据集**：在Indigo、ChemDraw、RDKit、CLEF、UOB、JPO、USPTO、Staker和ACS等数据集上表现优异

#### Toxic Colors
Toxic Colors使用2DConvNet处理"化学品的简单二维绘图"[23]，专注于毒性预测。该方法使用MOE软件生成分子图像，然后应用CNN进行毒性分类。

#### ADMET-CNN
ADMET-CNN是一种基于分子二维图像的CNN，**用于预测ADMET（吸收、分布、代谢、排泄、毒性）性质**[24]。该方法使用RDKit生成分子图像，然后训练CNN模型预测药物的ADMET性质。

## 三、应用和扩展

### 3.1 迁移学习和预训练

现代分子图像表示学习中，**迁移学习已成为一个重要趋势**。在医学领域，获取大量标记数据集通常很困难，迁移学习提供了解决方案[25]。

#### 预训练策略
1. **ImageNet预训练**：使用在ImageNet等大型图像数据集上预训练的CNN作为特征提取器
2. **自监督预训练**：如ImageMol使用的多任务预训练策略
3. **域适应**：将通用图像特征转移到化学领域

#### 数据增强技术
为了提高模型的泛化能力和鲁棒性，研究者开发了多种数据增强技术[26]：

1. **几何变换**：旋转、翻转、缩放
2. **颜色变换**：灰度化、对比度调整
3. **噪声添加**：添加高斯噪声、椒盐噪声
4. **分子特定增强**：随机删除原子或键

### 3.2 模型解释性

#### Grad-CAM分析
分子图像CNN模型可以使用Gradient-weighted Class Activation Mapping (Grad-CAM)进行解释[27]。**Grad-CAM能够识别模型关注的分子区域，帮助理解哪些结构特征对预测结果最重要**。

#### 特征可视化
通过可视化CNN不同层的激活模式，研究者可以理解模型学习到的化学特征：
- 低层特征：边缘、角度
- 中层特征：官能团、环结构
- 高层特征：复杂的分子骨架

### 3.3 多模态学习

#### 图像-文本联合学习
结合分子图像和SMILES/SELFIES等文本表示，可以实现更强大的分子表示学习[28]：
1. **对比学习**：学习图像和文本表示之间的对应关系
2. **多模态融合**：在决策层面融合不同模态的信息
3. **交叉注意力机制**：让图像和文本表示相互增强

#### 图像-图结构联合学习
结合2D分子图像和分子图结构，可以同时利用视觉信息和拓扑信息：
1. **联合编码**：同时处理图像和图结构
2. **知识蒸馏**：用图神经网络指导CNN学习
3. **多任务学习**：同时优化图像和图结构相关的任务

### 3.4 实际应用领域

#### 药物发现
1. **虚拟筛选**：从大型化合物库中筛选活性化合物
2. **药物重定位**：发现已知药物的新适应症
3. **ADMET预测**：预测药物的吸收、分布、代谢、排泄和毒性

#### 材料科学
1. **聚合物性质预测**：预测聚合物的物理化学性质
2. **催化剂设计**：设计高效的催化剂
3. **能源材料**：开发新型电池和太阳能材料

#### 环境科学
1. **污染物降解**：预测污染物的降解路径和速率[26]
2. **生态毒性评估**：评估化学品对环境的影响
3. **生物累积性预测**：预测化学品在生物体内的累积

### 3.5 技术挑战和未来方向

#### 当前挑战
1. **数据质量**：分子图像的标准化和质量控制
2. **可解释性**：提高模型预测的可解释性
3. **泛化能力**：在不同化学空间中的泛化性能
4. **计算效率**：处理大规模分子库的效率

#### 未来发展方向
1. **3D信息整合**：结合3D分子构象信息[29]
2. **动态性质预测**：预测分子的动态行为
3. **多尺度建模**：从分子到细胞到器官的多尺度预测
4. **自动化流程**：端到端的自动化预测流程

## 四、方法对比分析

### 4.1 主要方法对比表

| 方法 | 图像尺寸 | 绘图方法 | 特点 | 主要应用 | 优势 | 限制 |
|------|----------|----------|----------|------|------|------|
| **ImageMol** | 224×224 | MolsToGridImage | 自监督预训练<br/>多任务学习 | 分子性质预测<br/>药物靶点预测 | • 大规模预训练<br/>• 高精度<br/>• 迁移学习能力强 | • 计算资源需求高<br/>• 缺乏3D信息 |
| **Chemception** | 80×80<br/>48×48 | calculate pixels | 多通道编码<br/>（键级、原子序数、杂化、电荷） | 毒性预测<br/>活性预测<br/>溶解性预测 | • 化学信息丰富<br/>• 可解释性强<br/>• 计算效率高 | • 图像分辨率较低<br/>• 需要化学知识编码 |
| **DEEPScreen** | 200×200 | MolToFile | 药物-靶点相互作用<br/>大规模训练 | 虚拟筛选<br/>药物重定位 | • 专门针对DTI<br/>• 大规模数据库<br/>• 实用性强 | • 应用范围有限<br/>• 缺乏手性信息 |
| **KekuleScope** | 300×300 | MolsToGridImage | 凯库勒结构表示<br/>高分辨率 | 分子性质预测 | • 图像质量高<br/>• 标准化程度高 | • 数据处理复杂<br/>• 计算开销大 |
| **DECIMER** | 299×299 | --- | 图像到SMILES<br/>Transformer解码 | 光学结构识别<br/>文献挖掘 | • 实用工具<br/>• 端到端处理 | • 专门用途<br/>• 需要高质量图像 |

### 4.2 性能比较

#### 准确性方面
1. **ImageMol**：在多个基准数据集上表现最佳，特别是在CYP450抑制预测中
2. **Chemception**：在小数据集上表现良好，与专家开发的QSAR模型性能相当
3. **DEEPScreen**：在DTI预测任务中超越传统指纹方法

#### 计算效率
1. **Chemception**：图像尺寸小，训练和推理速度快
2. **ImageMol**：需要大量计算资源进行预训练，但推理相对高效
3. **DEEPScreen**：中等计算需求，适合实际应用

#### 可扩展性
1. **ImageMol**：预训练模型可以轻松适应新任务
2. **Chemception**：架构简单，易于修改和扩展
3. **DEEPScreen**：专门设计，扩展到其他任务需要重新训练

### 4.3 选择建议

#### 根据应用场景选择
1. **通用分子性质预测**：推荐ImageMol
2. **毒性和溶解性预测**：推荐Chemception
3. **药物-靶点相互作用**：推荐DEEPScreen
4. **图像识别任务**：推荐DECIMER

#### 根据资源条件选择
1. **计算资源丰富**：ImageMol或KekuleScope
2. **计算资源有限**：Chemception
3. **需要快速部署**：DEEPScreen

#### 根据数据特点选择
1. **大规模无标签数据**：ImageMol的自监督学习
2. **小规模标注数据**：Chemception的简单架构
3. **特定领域数据**：针对性训练的专用模型

## 参考文献

[1] Landrum G. RDKit: Open-source cheminformatics. 2020. Available: https://github.com/rdkit/rdkit

[2] RDKit Documentation. Getting Started with the RDKit in Python. Available: https://www.rdkit.org/docs/GettingStartedInPython.html

[3] RDKit Drawing Options Documentation. Available: https://www.rdkit.org/docs/source/rdkit.Chem.Draw.html

[4] RDKit 2D Coordinate Generation. Available: https://www.rdkit.org/docs/source/rdkit.Chem.rdDepictor.html

[5] RDKit AllChem Module Documentation. Available: https://www.rdkit.org/docs/source/rdkit.Chem.AllChem.html

[6] RDKit Advanced Drawing Documentation. Available: https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw2D.html

[7] Rifaioglu AS, Nalbat E, Atalay V, Martin MJ, Cetin-Atalay R, Doğan T. DEEPScreen: high performance drug–target interaction prediction with convolutional neural networks using 2-D structural compound representations. Chemical Science. 2020;11(9):2531-2557.

[8] Zeng X, Xiang H, Yu L, Wang J, Li K, Nussinov R, Cheng F. Accurate prediction of molecular properties and drug targets using a self-supervised image representation learning framework. Nature Machine Intelligence. 2022;4(11):1004-1016.

[9] Goh GB, Siegel C, Vishnu A, Hodas NO, Baker N. Chemception: A deep neural network with minimal chemistry knowledge matches the performance of expert-developed QSAR/QSPR models. 2017. arXiv preprint arXiv:1706.06689.

[10] RDKit Drawing Options Advanced Configuration. Available: https://www.rdkit.org/docs/source/rdkit.Chem.Draw.html#drawing-options

[11] RDKit Molecule Drawing Options. Available: https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw2D.html#drawing-options

[12] RDKit Color Customization. Available: https://www.rdkit.org/docs/Cookbook.html

[13] RDKit Cookbook. Available: https://www.rdkit.org/docs/Cookbook.html

[14] Xiang H. ImageMol: A molecular image-based pre-training deep learning framework for computational drug discovery. 2022. Available: https://github.com/HongxinXiang/ImageMol

[15] Li Y, Liu B, Deng J, Guo Y, Du H. Image-based molecular representation learning for drug development: a survey. Briefings in Bioinformatics. 2024;25(4):bbae294.

[16] Zeng X, Xiang H, Yu L, et al. Accurate prediction of molecular properties and drug targets using a self-supervised image representation learning framework. Nature Machine Intelligence. 2022;4(11):1004-1016.

[17] Goh GB, Siegel C, Vishnu A, Hodas NO, Baker N. Chemception: A deep neural network with minimal chemistry knowledge matches the performance of expert-developed QSAR/QSPR models. arXiv preprint arXiv:1706.06689. 2017.

[18] Wildcard Consulting. Learn how to teach your computer to see chemistry - free Chemception models with RDKit and Keras. Available: https://www.wildcardconsulting.dk/useful-information/learn-how-to-teach-your-computer-to-see-chemistry-free-chemception-models-with-rdkit-and-keras/

[19] Rifaioglu AS, Nalbat E, Atalay V, Martin MJ, Cetin-Atalay R, Doğan T. DEEPScreen: high performance drug–target interaction prediction with convolutional neural networks using 2-D structural compound representations. Chemical Science. 2020;11(9):2531-2557.

[20] KekuleScope GitHub Repository. Available: https://github.com/isidroc/kekulescope

[21] Rajan K, Zielesny A, Steinbeck C. DECIMER 1.0: deep learning for chemical image recognition using transformers. Journal of Cheminformatics. 2021;13(1):61.

[22] Chen BJ, Li C, Dai H, Song L. MolNexTR: A generalized deep learning model for molecular image recognition. Journal of Cheminformatics. 2024;16(1):7.

[23] Fernandez M, Ban F, Woo G, et al. Toxic Colors: The use of deep learning for predicting toxicity of compounds merely from their graphic images. Journal of Chemical Information and Modeling. 2018;58(8):1533-1543.

[24] Shi H, Liu S, Chen J, Li X, Ma Q, Yu B. Predicting drug-target interactions using Lasso with random forest based on evolutionary information and chemical structure. Genomics. 2019;111(6):1839-1852.

[25] Dalkiran A, Rifaioglu AS, Martin MJ, et al. ECPred: a tool for the prediction of the enzymatic functions of protein sequences based on the EC nomenclature. BMC Bioinformatics. 2018;19(1):334.

[26] Zhong S, Zhang K, Bagheri M, et al. Molecular image-convolutional neural network (CNN) assisted QSAR models for predicting contaminant reactivity toward OH radicals: Transfer learning, data augmentation and model interpretation. Chemical Engineering Journal. 2021;403:126393.

[27] Selvaraju RR, Cogswell M, Das A, et al. Grad-CAM: Visual explanations from deep networks via gradient-based localization. In: Proceedings of the IEEE International Conference on Computer Vision. 2017:618-626.

[28] Wang S, Guo Y, Wang Y, Sun H, Huang J. SMILES-BERT: Large scale unsupervised pre-training for molecular property prediction. In: Proceedings of the 10th ACM International Conference on Bioinformatics, Computational Biology and Health Informatics. 2019:429-436.

[29] Liu S, Guo H, Pan X, et al. A deep learning framework combining molecular image and protein structural representations identifies candidate drugs for pain. bioRxiv. 2024. doi:10.1101/2024.06.12.598706.

[30] Ståhl N, Falkman G, Karlsson A, Mathiason G, Boström J. Deep convolutional neural networks for the prediction of molecular properties: Challenges and opportunities connected to the data. Journal of Integrative Bioinformatics. 2019;16(1):20180065.